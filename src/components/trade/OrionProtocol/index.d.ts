import * as bignumber_js from 'bignumber.js';
import { BigNumber } from 'bignumber.js';
import * as zod from 'zod';
import { z, Schema, ZodTypeDef } from 'zod';
import { ethers, AddressLike, JsonRpcProvider, BigNumberish, Wallet } from 'ethers-v6';
import * as neverthrow from 'neverthrow';
import WebSocket from 'isomorphic-ws';
import WebSocket$1 from 'ws';
import * as _orionprotocol_contracts_lib_ethers_v6_Exchange_js from './contracts/lib/ethers-v6/Exchange.js';
import { LibValidator } from './contracts/lib/ethers-v6/Exchange.js';

declare const eip712DomainSchema: z.ZodEffects<z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    version: z.ZodOptional<z.ZodString>;
    chainId: z.ZodOptional<z.ZodString>;
    verifyingContract: z.ZodOptional<z.ZodString>;
    salt: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    name?: string | undefined;
    version?: string | undefined;
    chainId?: string | undefined;
    verifyingContract?: string | undefined;
    salt?: string | undefined;
}, {
    name?: string | undefined;
    version?: string | undefined;
    chainId?: string | undefined;
    verifyingContract?: string | undefined;
    salt?: string | undefined;
}>, {
    name?: string | undefined;
    version?: string | undefined;
    chainId?: string | undefined;
    verifyingContract?: string | undefined;
    salt?: string | undefined;
}, {
    name?: string | undefined;
    version?: string | undefined;
    chainId?: string | undefined;
    verifyingContract?: string | undefined;
    salt?: string | undefined;
}>;

declare const _default$4: readonly ["UniswapV2", "UniswapV3", "Curve", "OrionV2", "OrionV3"];

declare const subOrderStatuses: readonly ["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"];

declare const positionStatuses: readonly ["SHORT", "LONG", "CLOSING", "LIQUIDATION", "ZERO"];

declare const MessageType: {
    readonly ERROR: "e";
    readonly PING_PONG: "pp";
    readonly SWAP_INFO: "si";
    readonly INITIALIZATION: "i";
    readonly AGGREGATED_ORDER_BOOK_UPDATE: "aobu";
    readonly ASSET_PAIRS_CONFIG_UPDATE: "apcu";
    readonly ASSET_PAIR_CONFIG_UPDATE: "apiu";
    readonly ADDRESS_UPDATE: "au";
    readonly BROKER_TRADABLE_ATOMIC_SWAP_ASSETS_BALANCE_UPDATE: "btasabu";
    readonly UNSUBSCRIPTION_DONE: "ud";
};

declare const SubscriptionType$1: {
    readonly ASSET_PAIRS_CONFIG_UPDATES_SUBSCRIBE: "apcus";
    readonly ASSET_PAIR_CONFIG_UPDATES_SUBSCRIBE: "apius";
    readonly AGGREGATED_ORDER_BOOK_UPDATES_SUBSCRIBE: "aobus";
    readonly ADDRESS_UPDATES_SUBSCRIBE: "aus";
    readonly BROKER_TRADABLE_ATOMIC_SWAP_ASSETS_BALANCE_UPDATES_SUBSCRIBE: "btasabus";
    readonly SWAP_SUBSCRIBE: "ss";
};

declare const UnsubscriptionType: {
    readonly ASSET_PAIRS_CONFIG_UPDATES_UNSUBSCRIBE: "apcu";
    readonly BROKER_TRADABLE_ATOMIC_SWAP_ASSETS_BALANCE_UPDATES_UNSUBSCRIBE: "btasabu";
};

declare const orderUpdateSchema: z.ZodEffects<z.ZodEffects<z.ZodObject<{
    I: z.ZodString;
    A: z.ZodNumber;
    S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"]>;
    l: z.ZodOptional<z.ZodBoolean>;
    t: z.ZodNumber;
    C: z.ZodOptional<z.ZodString>;
    E: z.ZodOptional<z.ZodEnum<["LIMIT", "STOP_LIMIT"]>>;
    c: z.ZodArray<z.ZodObject<{
        i: z.ZodNumber;
        I: z.ZodString;
        O: z.ZodString;
        P: z.ZodString;
        s: z.ZodEnum<["BUY", "SELL"]>;
        a: z.ZodNumber;
        A: z.ZodNumber;
        p: z.ZodNumber;
        e: z.ZodString;
        es: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        b: z.ZodString;
        S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"]>;
        o: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }, {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    I: string;
    A: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    l?: boolean | undefined;
    C?: string | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
}, {
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    I: string;
    A: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    l?: boolean | undefined;
    C?: string | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
}>, {
    k: "update";
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    I: string;
    A: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    l?: boolean | undefined;
    C?: string | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
}, {
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    I: string;
    A: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    l?: boolean | undefined;
    C?: string | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
}>, {
    kind: "update";
    id: string;
    settledAmount: number;
    status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    liquidated: boolean | undefined;
    executionType: "LIMIT" | "STOP_LIMIT" | undefined;
    triggerCondition: string | undefined;
    subOrders: {
        pair: string;
        exchange: string;
        exchanges: string[] | undefined;
        id: number;
        amount: number;
        settledAmount: number;
        price: number;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        side: "BUY" | "SELL";
        subOrdQty: number;
    }[];
}, {
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    I: string;
    A: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    l?: boolean | undefined;
    C?: string | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
}>;
declare const fullOrderSchema: z.ZodEffects<z.ZodEffects<z.ZodObject<{
    I: z.ZodString;
    O: z.ZodString;
    P: z.ZodString;
    s: z.ZodEnum<["BUY", "SELL"]>;
    a: z.ZodNumber;
    A: z.ZodNumber;
    p: z.ZodNumber;
    F: z.ZodString;
    f: z.ZodNumber;
    l: z.ZodOptional<z.ZodBoolean>;
    L: z.ZodOptional<z.ZodNumber>;
    o: z.ZodBoolean;
    S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"]>;
    T: z.ZodNumber;
    t: z.ZodNumber;
    c: z.ZodArray<z.ZodObject<{
        i: z.ZodNumber;
        I: z.ZodString;
        O: z.ZodString;
        P: z.ZodString;
        s: z.ZodEnum<["BUY", "SELL"]>;
        a: z.ZodNumber;
        A: z.ZodNumber;
        p: z.ZodNumber;
        e: z.ZodString;
        es: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        b: z.ZodString;
        S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"]>;
        o: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }, {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }>, "many">;
    E: z.ZodOptional<z.ZodEnum<["LIMIT", "STOP_LIMIT"]>>;
    C: z.ZodOptional<z.ZodString>;
    ro: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    T: number;
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    o: boolean;
    I: string;
    O: string;
    P: string;
    s: "BUY" | "SELL";
    a: number;
    A: number;
    p: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    F: string;
    f: number;
    l?: boolean | undefined;
    L?: number | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
    C?: string | undefined;
    ro?: boolean | undefined;
}, {
    T: number;
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    o: boolean;
    I: string;
    O: string;
    P: string;
    s: "BUY" | "SELL";
    a: number;
    A: number;
    p: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    F: string;
    f: number;
    l?: boolean | undefined;
    L?: number | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
    C?: string | undefined;
    ro?: boolean | undefined;
}>, {
    k: "full";
    T: number;
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    o: boolean;
    I: string;
    O: string;
    P: string;
    s: "BUY" | "SELL";
    a: number;
    A: number;
    p: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    F: string;
    f: number;
    l?: boolean | undefined;
    L?: number | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
    C?: string | undefined;
    ro?: boolean | undefined;
}, {
    T: number;
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    o: boolean;
    I: string;
    O: string;
    P: string;
    s: "BUY" | "SELL";
    a: number;
    A: number;
    p: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    F: string;
    f: number;
    l?: boolean | undefined;
    L?: number | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
    C?: string | undefined;
    ro?: boolean | undefined;
}>, {
    kind: "full";
    id: string;
    settledAmount: number;
    feeAsset: string;
    fee: number;
    liquidated: boolean | undefined;
    stopPrice: number | undefined;
    status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    date: number;
    clientOrdId: string;
    type: "BUY" | "SELL";
    pair: string;
    amount: number;
    price: number;
    executionType: "LIMIT" | "STOP_LIMIT" | undefined;
    triggerCondition: string | undefined;
    isReversedOrder: boolean | undefined;
    subOrders: {
        pair: string;
        exchange: string;
        exchanges: string[] | undefined;
        id: number;
        amount: number;
        settledAmount: number;
        price: number;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        side: "BUY" | "SELL";
        subOrdQty: number;
    }[];
}, {
    T: number;
    S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
    o: boolean;
    I: string;
    O: string;
    P: string;
    s: "BUY" | "SELL";
    a: number;
    A: number;
    p: number;
    t: number;
    c: {
        e: string;
        i: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
        b: string;
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        es?: string[] | undefined;
    }[];
    F: string;
    f: number;
    l?: boolean | undefined;
    L?: number | undefined;
    E?: "LIMIT" | "STOP_LIMIT" | undefined;
    C?: string | undefined;
    ro?: boolean | undefined;
}>;
declare const addressUpdateSchema: z.ZodUnion<[z.ZodObject<{
    id: z.ZodString;
    T: z.ZodLiteral<"au">;
    _: z.ZodNumber;
    S: z.ZodString;
    uc: z.ZodArray<z.ZodEnum<["b", "o"]>, "many">;
    k: z.ZodLiteral<"i">;
    b: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodTuple<[z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>>, Partial<Record<string, [string, string, string, string, string]>>, Record<string, [string, string, string, string, string]>>;
    o: z.ZodOptional<z.ZodArray<z.ZodEffects<z.ZodEffects<z.ZodObject<{
        I: z.ZodString;
        O: z.ZodString;
        P: z.ZodString;
        s: z.ZodEnum<["BUY", "SELL"]>;
        a: z.ZodNumber;
        A: z.ZodNumber;
        p: z.ZodNumber;
        F: z.ZodString;
        f: z.ZodNumber;
        l: z.ZodOptional<z.ZodBoolean>;
        L: z.ZodOptional<z.ZodNumber>;
        o: z.ZodBoolean;
        S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"]>;
        T: z.ZodNumber;
        t: z.ZodNumber;
        c: z.ZodArray<z.ZodObject<{
            i: z.ZodNumber;
            I: z.ZodString;
            O: z.ZodString;
            P: z.ZodString;
            s: z.ZodEnum<["BUY", "SELL"]>;
            a: z.ZodNumber;
            A: z.ZodNumber;
            p: z.ZodNumber;
            e: z.ZodString;
            es: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            b: z.ZodString;
            S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"]>;
            o: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }, {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }>, "many">;
        E: z.ZodOptional<z.ZodEnum<["LIMIT", "STOP_LIMIT"]>>;
        C: z.ZodOptional<z.ZodString>;
        ro: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }>, {
        k: "full";
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }>, {
        kind: "full";
        id: string;
        settledAmount: number;
        feeAsset: string;
        fee: number;
        liquidated: boolean | undefined;
        stopPrice: number | undefined;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        date: number;
        clientOrdId: string;
        type: "BUY" | "SELL";
        pair: string;
        amount: number;
        price: number;
        executionType: "LIMIT" | "STOP_LIMIT" | undefined;
        triggerCondition: string | undefined;
        isReversedOrder: boolean | undefined;
        subOrders: {
            pair: string;
            exchange: string;
            exchanges: string[] | undefined;
            id: number;
            amount: number;
            settledAmount: number;
            price: number;
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            side: "BUY" | "SELL";
            subOrdQty: number;
        }[];
    }, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    id: string;
    T: "au";
    _: number;
    S: string;
    uc: ("b" | "o")[];
    b: Partial<Record<string, [string, string, string, string, string]>>;
    k: "i";
    o?: {
        kind: "full";
        id: string;
        settledAmount: number;
        feeAsset: string;
        fee: number;
        liquidated: boolean | undefined;
        stopPrice: number | undefined;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        date: number;
        clientOrdId: string;
        type: "BUY" | "SELL";
        pair: string;
        amount: number;
        price: number;
        executionType: "LIMIT" | "STOP_LIMIT" | undefined;
        triggerCondition: string | undefined;
        isReversedOrder: boolean | undefined;
        subOrders: {
            pair: string;
            exchange: string;
            exchanges: string[] | undefined;
            id: number;
            amount: number;
            settledAmount: number;
            price: number;
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            side: "BUY" | "SELL";
            subOrdQty: number;
        }[];
    }[] | undefined;
}, {
    id: string;
    T: "au";
    _: number;
    S: string;
    uc: ("b" | "o")[];
    b: Record<string, [string, string, string, string, string]>;
    k: "i";
    o?: {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }[] | undefined;
}>, z.ZodObject<{
    id: z.ZodString;
    T: z.ZodLiteral<"au">;
    _: z.ZodNumber;
    S: z.ZodString;
    k: z.ZodLiteral<"u">;
    uc: z.ZodArray<z.ZodEnum<["b", "o"]>, "many">;
    b: z.ZodOptional<z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodTuple<[z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>>, Partial<Record<string, [string, string, string, string, string]>>, Record<string, [string, string, string, string, string]>>>;
    o: z.ZodOptional<z.ZodTuple<[z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodObject<{
        I: z.ZodString;
        O: z.ZodString;
        P: z.ZodString;
        s: z.ZodEnum<["BUY", "SELL"]>;
        a: z.ZodNumber;
        A: z.ZodNumber;
        p: z.ZodNumber;
        F: z.ZodString;
        f: z.ZodNumber;
        l: z.ZodOptional<z.ZodBoolean>;
        L: z.ZodOptional<z.ZodNumber>;
        o: z.ZodBoolean;
        S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"]>;
        T: z.ZodNumber;
        t: z.ZodNumber;
        c: z.ZodArray<z.ZodObject<{
            i: z.ZodNumber;
            I: z.ZodString;
            O: z.ZodString;
            P: z.ZodString;
            s: z.ZodEnum<["BUY", "SELL"]>;
            a: z.ZodNumber;
            A: z.ZodNumber;
            p: z.ZodNumber;
            e: z.ZodString;
            es: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            b: z.ZodString;
            S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"]>;
            o: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }, {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }>, "many">;
        E: z.ZodOptional<z.ZodEnum<["LIMIT", "STOP_LIMIT"]>>;
        C: z.ZodOptional<z.ZodString>;
        ro: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }>, {
        k: "full";
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }>, {
        kind: "full";
        id: string;
        settledAmount: number;
        feeAsset: string;
        fee: number;
        liquidated: boolean | undefined;
        stopPrice: number | undefined;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        date: number;
        clientOrdId: string;
        type: "BUY" | "SELL";
        pair: string;
        amount: number;
        price: number;
        executionType: "LIMIT" | "STOP_LIMIT" | undefined;
        triggerCondition: string | undefined;
        isReversedOrder: boolean | undefined;
        subOrders: {
            pair: string;
            exchange: string;
            exchanges: string[] | undefined;
            id: number;
            amount: number;
            settledAmount: number;
            price: number;
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            side: "BUY" | "SELL";
            subOrdQty: number;
        }[];
    }, {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }>, z.ZodEffects<z.ZodEffects<z.ZodObject<{
        I: z.ZodString;
        A: z.ZodNumber;
        S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"]>;
        l: z.ZodOptional<z.ZodBoolean>;
        t: z.ZodNumber;
        C: z.ZodOptional<z.ZodString>;
        E: z.ZodOptional<z.ZodEnum<["LIMIT", "STOP_LIMIT"]>>;
        c: z.ZodArray<z.ZodObject<{
            i: z.ZodNumber;
            I: z.ZodString;
            O: z.ZodString;
            P: z.ZodString;
            s: z.ZodEnum<["BUY", "SELL"]>;
            a: z.ZodNumber;
            A: z.ZodNumber;
            p: z.ZodNumber;
            e: z.ZodString;
            es: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            b: z.ZodString;
            S: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"]>;
            o: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }, {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        I: string;
        A: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        l?: boolean | undefined;
        C?: string | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
    }, {
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        I: string;
        A: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        l?: boolean | undefined;
        C?: string | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
    }>, {
        k: "update";
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        I: string;
        A: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        l?: boolean | undefined;
        C?: string | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
    }, {
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        I: string;
        A: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        l?: boolean | undefined;
        C?: string | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
    }>, {
        kind: "update";
        id: string;
        settledAmount: number;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        liquidated: boolean | undefined;
        executionType: "LIMIT" | "STOP_LIMIT" | undefined;
        triggerCondition: string | undefined;
        subOrders: {
            pair: string;
            exchange: string;
            exchanges: string[] | undefined;
            id: number;
            amount: number;
            settledAmount: number;
            price: number;
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            side: "BUY" | "SELL";
            subOrdQty: number;
        }[];
    }, {
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        I: string;
        A: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        l?: boolean | undefined;
        C?: string | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
    }>]>], null>>;
}, "strip", z.ZodTypeAny, {
    id: string;
    T: "au";
    _: number;
    S: string;
    uc: ("b" | "o")[];
    k: "u";
    b?: Partial<Record<string, [string, string, string, string, string]>> | undefined;
    o?: [{
        kind: "update";
        id: string;
        settledAmount: number;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        liquidated: boolean | undefined;
        executionType: "LIMIT" | "STOP_LIMIT" | undefined;
        triggerCondition: string | undefined;
        subOrders: {
            pair: string;
            exchange: string;
            exchanges: string[] | undefined;
            id: number;
            amount: number;
            settledAmount: number;
            price: number;
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            side: "BUY" | "SELL";
            subOrdQty: number;
        }[];
    } | {
        kind: "full";
        id: string;
        settledAmount: number;
        feeAsset: string;
        fee: number;
        liquidated: boolean | undefined;
        stopPrice: number | undefined;
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        date: number;
        clientOrdId: string;
        type: "BUY" | "SELL";
        pair: string;
        amount: number;
        price: number;
        executionType: "LIMIT" | "STOP_LIMIT" | undefined;
        triggerCondition: string | undefined;
        isReversedOrder: boolean | undefined;
        subOrders: {
            pair: string;
            exchange: string;
            exchanges: string[] | undefined;
            id: number;
            amount: number;
            settledAmount: number;
            price: number;
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            side: "BUY" | "SELL";
            subOrdQty: number;
        }[];
    }] | undefined;
}, {
    id: string;
    T: "au";
    _: number;
    S: string;
    uc: ("b" | "o")[];
    k: "u";
    b?: Record<string, [string, string, string, string, string]> | undefined;
    o?: [{
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        I: string;
        A: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        l?: boolean | undefined;
        C?: string | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
    } | {
        T: number;
        S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        o: boolean;
        I: string;
        O: string;
        P: string;
        s: "BUY" | "SELL";
        a: number;
        A: number;
        p: number;
        t: number;
        c: {
            e: string;
            i: number;
            S: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            b: string;
            o: boolean;
            I: string;
            O: string;
            P: string;
            s: "BUY" | "SELL";
            a: number;
            A: number;
            p: number;
            es?: string[] | undefined;
        }[];
        F: string;
        f: number;
        l?: boolean | undefined;
        L?: number | undefined;
        E?: "LIMIT" | "STOP_LIMIT" | undefined;
        C?: string | undefined;
        ro?: boolean | undefined;
    }] | undefined;
}>]>;

declare const assetPairsConfigSchema: z.ZodObject<{
    _: z.ZodNumber;
    id: z.ZodString;
    T: z.ZodLiteral<"apcu">;
    k: z.ZodEnum<["i", "u"]>;
    u: z.ZodArray<z.ZodTuple<[z.ZodString, z.ZodNumber, z.ZodNumber], null>, "many">;
}, "strip", z.ZodTypeAny, {
    id: string;
    T: "apcu";
    _: number;
    k: "i" | "u";
    u: [string, number, number][];
}, {
    id: string;
    T: "apcu";
    _: number;
    k: "i" | "u";
    u: [string, number, number][];
}>;

declare const baseMessageSchema: z.ZodObject<{
    T: z.ZodNativeEnum<{
        readonly ERROR: "e";
        readonly PING_PONG: "pp";
        readonly SWAP_INFO: "si";
        readonly INITIALIZATION: "i";
        readonly AGGREGATED_ORDER_BOOK_UPDATE: "aobu";
        readonly ASSET_PAIRS_CONFIG_UPDATE: "apcu";
        readonly ASSET_PAIR_CONFIG_UPDATE: "apiu";
        readonly ADDRESS_UPDATE: "au";
        readonly BROKER_TRADABLE_ATOMIC_SWAP_ASSETS_BALANCE_UPDATE: "btasabu";
        readonly UNSUBSCRIPTION_DONE: "ud";
    }>;
    _: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    T: "e" | "pp" | "si" | "i" | "aobu" | "apcu" | "apiu" | "au" | "btasabu" | "ud";
    _: number;
}, {
    T: "e" | "pp" | "si" | "i" | "aobu" | "apcu" | "apiu" | "au" | "btasabu" | "ud";
    _: number;
}>;

declare const brokerMessageSchema: z.ZodObject<{
    _: z.ZodNumber;
    T: z.ZodLiteral<"btasabu">;
    bb: z.ZodArray<z.ZodTuple<[z.ZodString, z.ZodNumber], null>, "many">;
}, "strip", z.ZodTypeAny, {
    T: "btasabu";
    _: number;
    bb: [string, number][];
}, {
    T: "btasabu";
    _: number;
    bb: [string, number][];
}>;

declare const errorSchema$2: z.ZodObject<{
    _: z.ZodNumber;
    T: z.ZodLiteral<"e">;
    c: z.ZodNumber;
    id: z.ZodOptional<z.ZodString>;
    m: z.ZodString;
}, "strip", z.ZodTypeAny, {
    T: "e";
    _: number;
    c: number;
    m: string;
    id?: string | undefined;
}, {
    T: "e";
    _: number;
    c: number;
    m: string;
    id?: string | undefined;
}>;

declare const initMessageSchema: z.ZodObject<{
    _: z.ZodNumber;
    T: z.ZodLiteral<"i">;
    i: z.ZodString;
}, "strip", z.ZodTypeAny, {
    i: string;
    T: "i";
    _: number;
}, {
    i: string;
    T: "i";
    _: number;
}>;

declare const pingPongMessageSchema: z.ZodObject<{
    _: z.ZodNumber;
    T: z.ZodLiteral<"pp">;
}, "strip", z.ZodTypeAny, {
    T: "pp";
    _: number;
}, {
    T: "pp";
    _: number;
}>;

declare const swapInfoSchema$1: z.ZodUnion<[z.ZodEffects<z.ZodObject<{
    usd: z.ZodOptional<z.ZodObject<{
        aa: z.ZodOptional<z.ZodNumber>;
        aao: z.ZodOptional<z.ZodNumber>;
        mo: z.ZodOptional<z.ZodNumber>;
        mi: z.ZodOptional<z.ZodNumber>;
        d: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }>>;
    e: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    T: z.ZodLiteral<"si">;
    _: z.ZodNumber;
    S: z.ZodString;
    o: z.ZodNumber;
    a: z.ZodNumber;
    p: z.ZodOptional<z.ZodNumber>;
    ps: z.ZodArray<z.ZodString, "many">;
    mp: z.ZodOptional<z.ZodNumber>;
    ai: z.ZodString;
    ao: z.ZodString;
    ma: z.ZodNumber;
    mao: z.ZodNumber;
    po: z.ZodBoolean;
    oi: z.ZodOptional<z.ZodObject<{
        p: z.ZodString;
        s: z.ZodEnum<["SELL", "BUY"]>;
        a: z.ZodNumber;
        sp: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    }, {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    }>>;
    as: z.ZodArray<z.ZodObject<{
        e: z.ZodArray<z.ZodString, "many">;
        ps: z.ZodArray<z.ZodString, "many">;
        mo: z.ZodOptional<z.ZodNumber>;
        mi: z.ZodOptional<z.ZodNumber>;
        mp: z.ZodNumber;
        aa: z.ZodOptional<z.ZodNumber>;
        aao: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }, {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }>, "many">;
    anm: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    eps: z.ZodArray<z.ZodObject<{
        p: z.ZodString;
        ai: z.ZodString;
        ao: z.ZodString;
        f: z.ZodEnum<["UniswapV2", "UniswapV3", "Curve", "OrionV2", "OrionV3"]>;
    }, "strip", z.ZodTypeAny, {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }, {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }>, "many">;
    sl: z.ZodOptional<z.ZodNumber>;
    mo: z.ZodOptional<z.ZodNumber>;
    aa: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    aa: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mo?: number | undefined;
}, {
    aa: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mo?: number | undefined;
}>, {
    k: "exactSpend";
    aa: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mo?: number | undefined;
}, {
    aa: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mo?: number | undefined;
}>, z.ZodEffects<z.ZodObject<{
    usd: z.ZodOptional<z.ZodObject<{
        aa: z.ZodOptional<z.ZodNumber>;
        aao: z.ZodOptional<z.ZodNumber>;
        mo: z.ZodOptional<z.ZodNumber>;
        mi: z.ZodOptional<z.ZodNumber>;
        d: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }>>;
    e: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    T: z.ZodLiteral<"si">;
    _: z.ZodNumber;
    S: z.ZodString;
    o: z.ZodNumber;
    a: z.ZodNumber;
    p: z.ZodOptional<z.ZodNumber>;
    ps: z.ZodArray<z.ZodString, "many">;
    mp: z.ZodOptional<z.ZodNumber>;
    ai: z.ZodString;
    ao: z.ZodString;
    ma: z.ZodNumber;
    mao: z.ZodNumber;
    po: z.ZodBoolean;
    oi: z.ZodOptional<z.ZodObject<{
        p: z.ZodString;
        s: z.ZodEnum<["SELL", "BUY"]>;
        a: z.ZodNumber;
        sp: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    }, {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    }>>;
    as: z.ZodArray<z.ZodObject<{
        e: z.ZodArray<z.ZodString, "many">;
        ps: z.ZodArray<z.ZodString, "many">;
        mo: z.ZodOptional<z.ZodNumber>;
        mi: z.ZodOptional<z.ZodNumber>;
        mp: z.ZodNumber;
        aa: z.ZodOptional<z.ZodNumber>;
        aao: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }, {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }>, "many">;
    anm: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    eps: z.ZodArray<z.ZodObject<{
        p: z.ZodString;
        ai: z.ZodString;
        ao: z.ZodString;
        f: z.ZodEnum<["UniswapV2", "UniswapV3", "Curve", "OrionV2", "OrionV3"]>;
    }, "strip", z.ZodTypeAny, {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }, {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }>, "many">;
    sl: z.ZodOptional<z.ZodNumber>;
    mi: z.ZodOptional<z.ZodNumber>;
    aao: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    aao: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mi?: number | undefined;
}, {
    aao: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mi?: number | undefined;
}>, {
    k: "exactReceive";
    aao: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mi?: number | undefined;
}, {
    aao: number;
    T: "si";
    _: number;
    S: string;
    o: number;
    a: number;
    ps: string[];
    ai: string;
    ao: string;
    ma: number;
    mao: number;
    po: boolean;
    as: {
        e: string[];
        ps: string[];
        mp: number;
        mo?: number | undefined;
        mi?: number | undefined;
        aa?: number | undefined;
        aao?: number | undefined;
    }[];
    eps: {
        p: string;
        f: "UniswapV2" | "UniswapV3" | "Curve" | "OrionV2" | "OrionV3";
        ai: string;
        ao: string;
    }[];
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    e?: string[] | undefined;
    p?: number | undefined;
    mp?: number | undefined;
    oi?: {
        s: "BUY" | "SELL";
        a: number;
        p: string;
        sp: number;
    } | undefined;
    anm?: Record<string, string> | undefined;
    sl?: number | undefined;
    mi?: number | undefined;
}>]>;

declare const balancesSchema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodTuple<[z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>>, Partial<Record<string, [string, string, string, string, string]>>, Record<string, [string, string, string, string, string]>>;

declare const orderBookItemSchema: z.ZodTuple<[z.ZodString, z.ZodString, z.ZodArray<z.ZodString, "many">, z.ZodArray<z.ZodTuple<[z.ZodEnum<["SELL", "BUY"]>, z.ZodString], null>, "many">], null>;
declare const orderBookSchema: z.ZodObject<{
    _: z.ZodNumber;
    T: z.ZodLiteral<"aobu">;
    S: z.ZodString;
    ob: z.ZodObject<{
        a: z.ZodArray<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodArray<z.ZodString, "many">, z.ZodArray<z.ZodTuple<[z.ZodEnum<["SELL", "BUY"]>, z.ZodString], null>, "many">], null>, "many">;
        b: z.ZodArray<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodArray<z.ZodString, "many">, z.ZodArray<z.ZodTuple<[z.ZodEnum<["SELL", "BUY"]>, z.ZodString], null>, "many">], null>, "many">;
    }, "strip", z.ZodTypeAny, {
        b: [string, string, string[], ["BUY" | "SELL", string][]][];
        a: [string, string, string[], ["BUY" | "SELL", string][]][];
    }, {
        b: [string, string, string[], ["BUY" | "SELL", string][]][];
        a: [string, string, string[], ["BUY" | "SELL", string][]][];
    }>;
}, "strip", z.ZodTypeAny, {
    T: "aobu";
    _: number;
    S: string;
    ob: {
        b: [string, string, string[], ["BUY" | "SELL", string][]][];
        a: [string, string, string[], ["BUY" | "SELL", string][]][];
    };
}, {
    T: "aobu";
    _: number;
    S: string;
    ob: {
        b: [string, string, string[], ["BUY" | "SELL", string][]][];
        a: [string, string, string[], ["BUY" | "SELL", string][]][];
    };
}>;

declare const index$k_addressUpdateSchema: typeof addressUpdateSchema;
declare const index$k_assetPairsConfigSchema: typeof assetPairsConfigSchema;
declare const index$k_balancesSchema: typeof balancesSchema;
declare const index$k_baseMessageSchema: typeof baseMessageSchema;
declare const index$k_brokerMessageSchema: typeof brokerMessageSchema;
declare const index$k_initMessageSchema: typeof initMessageSchema;
declare const index$k_orderBookItemSchema: typeof orderBookItemSchema;
declare const index$k_orderBookSchema: typeof orderBookSchema;
declare const index$k_pingPongMessageSchema: typeof pingPongMessageSchema;
declare namespace index$k {
    export {
        index$k_addressUpdateSchema as addressUpdateSchema,
        index$k_assetPairsConfigSchema as assetPairsConfigSchema,
        index$k_balancesSchema as balancesSchema,
        index$k_baseMessageSchema as baseMessageSchema,
        index$k_brokerMessageSchema as brokerMessageSchema,
        errorSchema$2 as errorSchema,
        index$k_initMessageSchema as initMessageSchema,
        index$k_orderBookItemSchema as orderBookItemSchema,
        index$k_orderBookSchema as orderBookSchema,
        index$k_pingPongMessageSchema as pingPongMessageSchema,
        swapInfoSchema$1 as swapInfoSchema,
    };
}

type SwapInfoSubscriptionPayload = {
    i: string;
    o: string;
    a: number;
    es?: string;
    e?: boolean;
    is?: boolean;
};
type BrokerTradableAtomicSwapBalanceSubscription = {
    callback: (balances: Partial<Record<string, number>>) => void;
};
type PairsConfigSubscription = {
    callback: ({ kind, data }: {
        kind: 'initial' | 'update';
        data: Partial<Record<string, AssetPairUpdate>>;
    }) => void;
};
type PairConfigSubscription = {
    payload: string;
    callback: ({ kind, data }: {
        kind: 'initial' | 'update';
        data: AssetPairUpdate;
    }) => void;
};
type AggregatedOrderbookSubscription = {
    payload: string;
    dc?: number;
    callback: (asks: OrderbookItem[], bids: OrderbookItem[], pair: string) => void;
    errorCb?: (message: string) => void;
};
type SwapInfoSubscription = {
    payload: SwapInfoSubscriptionPayload;
    callback: (swapInfo: SwapInfo) => void;
};
type AddressUpdateUpdate = {
    kind: 'update';
    balances: Partial<Record<string, Balance>>;
    order?: z.infer<typeof orderUpdateSchema> | z.infer<typeof fullOrderSchema> | undefined;
};
type AddressUpdateInitial = {
    kind: 'initial';
    balances: Partial<Record<string, Balance>>;
    orders?: Array<z.infer<typeof fullOrderSchema>> | undefined;
};
type AddressUpdateSubscription = {
    payload: string;
    callback: (data: AddressUpdateUpdate | AddressUpdateInitial) => void;
    errorCb?: (message: string) => void;
};
type Subscription$1 = {
    [SubscriptionType$1.ADDRESS_UPDATES_SUBSCRIBE]: AddressUpdateSubscription;
    [SubscriptionType$1.AGGREGATED_ORDER_BOOK_UPDATES_SUBSCRIBE]: AggregatedOrderbookSubscription;
    [SubscriptionType$1.ASSET_PAIRS_CONFIG_UPDATES_SUBSCRIBE]: PairsConfigSubscription;
    [SubscriptionType$1.ASSET_PAIR_CONFIG_UPDATES_SUBSCRIBE]: PairConfigSubscription;
    [SubscriptionType$1.BROKER_TRADABLE_ATOMIC_SWAP_ASSETS_BALANCE_UPDATES_SUBSCRIBE]: BrokerTradableAtomicSwapBalanceSubscription;
    [SubscriptionType$1.SWAP_SUBSCRIBE]: SwapInfoSubscription;
};
type Subscriptions = Partial<{
    [K in keyof Subscription$1]: Partial<Record<string, Subscription$1[K]>>;
}>;
declare class AggregatorWS {
    private ws?;
    private isClosedIntentionally;
    readonly subscriptions: Subscriptions;
    onInit: (() => void) | undefined;
    onWSOpen: ((event: WebSocket.Event) => void) | undefined;
    onWSClose: ((event: WebSocket.CloseEvent) => void) | undefined;
    onError: ((err: string) => void) | undefined;
    logger: ((message: string) => void) | undefined;
    private subIdReplacements;
    private readonly wsUrl;
    private isAlive;
    get api(): URL;
    readonly instanceId: string;
    readonly basicAuth?: BasicAuthCredentials | undefined;
    constructor(wsUrl: string, basicAuth?: BasicAuthCredentials, logger?: ((message: string) => void) | undefined);
    private messageQueue;
    private sendWsMessage;
    private readonly handleWsOpen;
    private sendRaw;
    private send;
    private hearbeatIntervalId;
    private setupHeartbeat;
    private clearHeartbeat;
    subscribe<T extends typeof SubscriptionType$1[keyof typeof SubscriptionType$1]>(type: T, subscription: Subscription$1[T], prevSubscriptionId?: string): string;
    /**
     * Returns newest subscription id for given id. Subscription id can be changed during resubscription.
     * This function ensure that old subscription id will be replaced with newest one.
     * @param id Id of subscription
     * @returns Newest subscription id
     */
    getNewestSubscriptionId(id: string): string;
    unsubscribe(subscription: keyof typeof UnsubscriptionType | string, details?: string): void;
    destroy(): void;
    private init;
}

type index$j_AggregatorWS = AggregatorWS;
declare const index$j_AggregatorWS: typeof AggregatorWS;
declare const index$j_MessageType: typeof MessageType;
declare const index$j_UnsubscriptionType: typeof UnsubscriptionType;
declare namespace index$j {
    export {
        index$j_AggregatorWS as AggregatorWS,
        index$j_MessageType as MessageType,
        SubscriptionType$1 as SubscriptionType,
        index$j_UnsubscriptionType as UnsubscriptionType,
        index$k as schemas,
    };
}

declare const _default$3: readonly ["ftm", "bsc", "eth", "polygon", "okc", "arb", "drip", "opbnb", "inevm", "linea", "avax", "base"];

declare const pmmOrderSchema: z.ZodObject<{
    order: z.ZodDefault<z.ZodObject<{
        info: z.ZodDefault<z.ZodString>;
        makerAsset: z.ZodDefault<z.ZodString>;
        takerAsset: z.ZodDefault<z.ZodString>;
        maker: z.ZodDefault<z.ZodString>;
        allowedSender: z.ZodDefault<z.ZodString>;
        makingAmount: z.ZodDefault<z.ZodString>;
        takingAmount: z.ZodDefault<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        info: string;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: string;
        takingAmount: string;
    }, {
        info?: string | undefined;
        makerAsset?: string | undefined;
        takerAsset?: string | undefined;
        maker?: string | undefined;
        allowedSender?: string | undefined;
        makingAmount?: string | undefined;
        takingAmount?: string | undefined;
    }>>;
    signature: z.ZodDefault<z.ZodString>;
    success: z.ZodDefault<z.ZodBoolean>;
    error: z.ZodDefault<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    error: string;
    signature: string;
    success: boolean;
    order: {
        info: string;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: string;
        takingAmount: string;
    };
}, {
    order?: {
        info?: string | undefined;
        makerAsset?: string | undefined;
        takerAsset?: string | undefined;
        maker?: string | undefined;
        allowedSender?: string | undefined;
        makingAmount?: string | undefined;
        takingAmount?: string | undefined;
    } | undefined;
    signature?: string | undefined;
    success?: boolean | undefined;
    error?: string | undefined;
}>;

declare const atomicSwapHistorySchema: z.ZodArray<z.ZodObject<{
    id: z.ZodString;
    sender: z.ZodString;
    lockOrder: z.ZodObject<{
        sender: z.ZodString;
        asset: z.ZodString;
        amount: z.ZodNumber;
        expiration: z.ZodNumber;
        secretHash: z.ZodString;
        used: z.ZodBoolean;
        sourceNetworkCode: z.ZodEnum<["FTM", "BSC", "ETH", "POLYGON", "OKC", "ARB", "OPBNB", "INEVM", "LINEA", "AVAX", "BASE"]>;
    }, "strip", z.ZodTypeAny, {
        amount: number;
        asset: string;
        expiration: number;
        secretHash: string;
        sender: string;
        used: boolean;
        sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
    }, {
        amount: number;
        asset: string;
        expiration: number;
        secretHash: string;
        sender: string;
        used: boolean;
        sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
    }>;
    redeemOrder: z.ZodObject<{
        asset: z.ZodString;
        amount: z.ZodNumber;
        secretHash: z.ZodString;
        sender: z.ZodString;
        receiver: z.ZodString;
        expiration: z.ZodNumber;
        signature: z.ZodString;
        claimReceiver: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    }, {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    }>;
    status: z.ZodEnum<["SETTLED", "EXPIRED", "ACTIVE"]>;
    creationTime: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    status: "SETTLED" | "EXPIRED" | "ACTIVE";
    id: string;
    redeemOrder: {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    };
    sender: string;
    lockOrder: {
        amount: number;
        asset: string;
        expiration: number;
        secretHash: string;
        sender: string;
        used: boolean;
        sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
    };
    creationTime: number;
}, {
    status: "SETTLED" | "EXPIRED" | "ACTIVE";
    id: string;
    redeemOrder: {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    };
    sender: string;
    lockOrder: {
        amount: number;
        asset: string;
        expiration: number;
        secretHash: string;
        sender: string;
        used: boolean;
        sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
    };
    creationTime: number;
}>, "many">;

declare const cancelOrderSchema: z.ZodObject<{
    orderId: z.ZodUnion<[z.ZodNumber, z.ZodString]>;
    cancellationRequests: z.ZodOptional<z.ZodArray<z.ZodObject<{
        amount: z.ZodNumber;
        brokerAddress: z.ZodString;
        exchange: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        amount: number;
        brokerAddress: string;
        exchange: string;
    }, {
        amount: number;
        brokerAddress: string;
        exchange: string;
    }>, "many">>;
    remainingAmount: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    orderId: string | number;
    cancellationRequests?: {
        amount: number;
        brokerAddress: string;
        exchange: string;
    }[] | undefined;
    remainingAmount?: number | undefined;
}, {
    orderId: string | number;
    cancellationRequests?: {
        amount: number;
        brokerAddress: string;
        exchange: string;
    }[] | undefined;
    remainingAmount?: number | undefined;
}>;

declare const exchangeInfoSchema: z.ZodArray<z.ZodObject<{
    maxPrice: z.ZodNumber;
    maxQty: z.ZodNumber;
    minPrice: z.ZodNumber;
    minQty: z.ZodNumber;
    name: z.ZodString;
    pricePrecision: z.ZodNumber;
    qtyPrecision: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    name: string;
    maxPrice: number;
    maxQty: number;
    minPrice: number;
    minQty: number;
    pricePrecision: number;
    qtyPrecision: number;
}, {
    name: string;
    maxPrice: number;
    maxQty: number;
    minPrice: number;
    minQty: number;
    pricePrecision: number;
    qtyPrecision: number;
}>, "many">;

declare const orderBenefitsSchema: z.ZodRecord<z.ZodString, z.ZodObject<{
    benefitBtc: z.ZodString;
    benefitPct: z.ZodString;
}, "strip", z.ZodTypeAny, {
    benefitBtc: string;
    benefitPct: string;
}, {
    benefitBtc: string;
    benefitPct: string;
}>>;

declare const pairConfigSchema: z.ZodObject<{
    maxPrice: z.ZodNumber;
    maxQty: z.ZodNumber;
    minPrice: z.ZodNumber;
    minQty: z.ZodNumber;
    name: z.ZodString;
    pricePrecision: z.ZodNumber;
    qtyPrecision: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    name: string;
    maxPrice: number;
    maxQty: number;
    minPrice: number;
    minQty: number;
    pricePrecision: number;
    qtyPrecision: number;
}, {
    name: string;
    maxPrice: number;
    maxQty: number;
    minPrice: number;
    minQty: number;
    pricePrecision: number;
    qtyPrecision: number;
}>;

declare const placeAtomicSwapSchema: z.ZodObject<{
    redeemOrder: z.ZodObject<{
        amount: z.ZodNumber;
        asset: z.ZodString;
        expiration: z.ZodNumber;
        receiver: z.ZodString;
        secretHash: z.ZodString;
        sender: z.ZodString;
        signature: z.ZodString;
        claimReceiver: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    }, {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    }>;
    secretHash: z.ZodString;
    sender: z.ZodString;
}, "strip", z.ZodTypeAny, {
    redeemOrder: {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    };
    secretHash: string;
    sender: string;
}, {
    redeemOrder: {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    };
    secretHash: string;
    sender: string;
}>;

declare const redeemOrderSchema: z.ZodObject<{
    asset: z.ZodString;
    amount: z.ZodNumber;
    secretHash: z.ZodString;
    sender: z.ZodString;
    receiver: z.ZodString;
    expiration: z.ZodNumber;
    signature: z.ZodString;
    claimReceiver: z.ZodString;
}, "strip", z.ZodTypeAny, {
    amount: number;
    asset: string;
    expiration: number;
    receiver: string;
    secretHash: string;
    sender: string;
    signature: string;
    claimReceiver: string;
}, {
    amount: number;
    asset: string;
    expiration: number;
    receiver: string;
    secretHash: string;
    sender: string;
    signature: string;
    claimReceiver: string;
}>;

declare const swapInfoSchema: z.ZodUnion<[z.ZodEffects<z.ZodObject<{
    path: z.ZodArray<z.ZodString, "many">;
    assetIn: z.ZodString;
    assetOut: z.ZodString;
    id: z.ZodString;
    amountIn: z.ZodNumber;
    amountOut: z.ZodNumber;
    executionInfo: z.ZodString;
    orderInfo: z.ZodNullable<z.ZodObject<{
        assetPair: z.ZodString;
        side: z.ZodEnum<["BUY", "SELL"]>;
        amount: z.ZodNumber;
        safePrice: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    }, {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    }>>;
    exchanges: z.ZodArray<z.ZodString, "many">;
    price: z.ZodNullable<z.ZodNumber>;
    minAmountOut: z.ZodNumber;
    minAmountIn: z.ZodNumber;
    marketPrice: z.ZodNullable<z.ZodNumber>;
    exchangeContractPath: z.ZodArray<z.ZodObject<{
        pool: z.ZodString;
        assetIn: z.ZodString;
        assetOut: z.ZodString;
        factory: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }, {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }>, "many">;
    alternatives: z.ZodArray<z.ZodObject<{
        exchanges: z.ZodArray<z.ZodString, "many">;
        path: z.ZodArray<z.ZodString, "many">;
        marketAmountOut: z.ZodNullable<z.ZodNumber>;
        marketAmountIn: z.ZodNullable<z.ZodNumber>;
        marketPrice: z.ZodNumber;
        availableAmountIn: z.ZodNullable<z.ZodNumber>;
        availableAmountOut: z.ZodNullable<z.ZodNumber>;
        orderInfo: z.ZodNullable<z.ZodObject<{
            assetPair: z.ZodString;
            side: z.ZodEnum<["BUY", "SELL"]>;
            amount: z.ZodNumber;
            safePrice: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        }, {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        }>>;
        isThroughPoolOrCurve: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }, {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }>, "many">;
    assetNameMapping: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    usd: z.ZodOptional<z.ZodObject<{
        aa: z.ZodOptional<z.ZodNumber>;
        aao: z.ZodOptional<z.ZodNumber>;
        mo: z.ZodOptional<z.ZodNumber>;
        mi: z.ZodOptional<z.ZodNumber>;
        d: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }>>;
    autoSlippage: z.ZodOptional<z.ZodNumber>;
    availableAmountOut: z.ZodNull;
    availableAmountIn: z.ZodNumber;
    marketAmountOut: z.ZodNullable<z.ZodNumber>;
    marketAmountIn: z.ZodNull;
}, "strip", z.ZodTypeAny, {
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: number | null;
    marketAmountIn: null;
    availableAmountIn: number;
    availableAmountOut: null;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}, {
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: number | null;
    marketAmountIn: null;
    availableAmountIn: number;
    availableAmountOut: null;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}>, {
    type: "exactSpend";
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: number | null;
    marketAmountIn: null;
    availableAmountIn: number;
    availableAmountOut: null;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}, {
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: number | null;
    marketAmountIn: null;
    availableAmountIn: number;
    availableAmountOut: null;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}>, z.ZodEffects<z.ZodObject<{
    path: z.ZodArray<z.ZodString, "many">;
    assetIn: z.ZodString;
    assetOut: z.ZodString;
    id: z.ZodString;
    amountIn: z.ZodNumber;
    amountOut: z.ZodNumber;
    executionInfo: z.ZodString;
    orderInfo: z.ZodNullable<z.ZodObject<{
        assetPair: z.ZodString;
        side: z.ZodEnum<["BUY", "SELL"]>;
        amount: z.ZodNumber;
        safePrice: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    }, {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    }>>;
    exchanges: z.ZodArray<z.ZodString, "many">;
    price: z.ZodNullable<z.ZodNumber>;
    minAmountOut: z.ZodNumber;
    minAmountIn: z.ZodNumber;
    marketPrice: z.ZodNullable<z.ZodNumber>;
    exchangeContractPath: z.ZodArray<z.ZodObject<{
        pool: z.ZodString;
        assetIn: z.ZodString;
        assetOut: z.ZodString;
        factory: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }, {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }>, "many">;
    alternatives: z.ZodArray<z.ZodObject<{
        exchanges: z.ZodArray<z.ZodString, "many">;
        path: z.ZodArray<z.ZodString, "many">;
        marketAmountOut: z.ZodNullable<z.ZodNumber>;
        marketAmountIn: z.ZodNullable<z.ZodNumber>;
        marketPrice: z.ZodNumber;
        availableAmountIn: z.ZodNullable<z.ZodNumber>;
        availableAmountOut: z.ZodNullable<z.ZodNumber>;
        orderInfo: z.ZodNullable<z.ZodObject<{
            assetPair: z.ZodString;
            side: z.ZodEnum<["BUY", "SELL"]>;
            amount: z.ZodNumber;
            safePrice: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        }, {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        }>>;
        isThroughPoolOrCurve: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }, {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }>, "many">;
    assetNameMapping: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    usd: z.ZodOptional<z.ZodObject<{
        aa: z.ZodOptional<z.ZodNumber>;
        aao: z.ZodOptional<z.ZodNumber>;
        mo: z.ZodOptional<z.ZodNumber>;
        mi: z.ZodOptional<z.ZodNumber>;
        d: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }, {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    }>>;
    autoSlippage: z.ZodOptional<z.ZodNumber>;
    availableAmountOut: z.ZodNumber;
    availableAmountIn: z.ZodNull;
    marketAmountOut: z.ZodNull;
    marketAmountIn: z.ZodNullable<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: null;
    marketAmountIn: number | null;
    availableAmountIn: null;
    availableAmountOut: number;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}, {
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: null;
    marketAmountIn: number | null;
    availableAmountIn: null;
    availableAmountOut: number;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}>, {
    type: "exactReceive";
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: null;
    marketAmountIn: number | null;
    availableAmountIn: null;
    availableAmountOut: number;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}, {
    path: string[];
    assetIn: string;
    assetOut: string;
    id: string;
    amountIn: number;
    amountOut: number;
    executionInfo: string;
    orderInfo: {
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        safePrice: number;
    } | null;
    exchanges: string[];
    price: number | null;
    minAmountOut: number;
    minAmountIn: number;
    marketPrice: number | null;
    exchangeContractPath: {
        pool: string;
        assetIn: string;
        assetOut: string;
        factory: string;
    }[];
    marketAmountOut: null;
    marketAmountIn: number | null;
    availableAmountIn: null;
    availableAmountOut: number;
    alternatives: {
        path: string[];
        orderInfo: {
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            safePrice: number;
        } | null;
        exchanges: string[];
        marketPrice: number;
        marketAmountOut: number | null;
        marketAmountIn: number | null;
        availableAmountIn: number | null;
        availableAmountOut: number | null;
        isThroughPoolOrCurve: boolean;
    }[];
    assetNameMapping?: Record<string, string> | undefined;
    usd?: {
        aa?: number | undefined;
        aao?: number | undefined;
        mo?: number | undefined;
        mi?: number | undefined;
        d?: string | undefined;
    } | undefined;
    autoSlippage?: number | undefined;
}>]>;

declare const orderSchema: z.ZodObject<{
    orderId: z.ZodEffects<z.ZodString, `0x${string}`, string>;
    order: z.ZodObject<{
        assetPair: z.ZodString;
        side: z.ZodEnum<["BUY", "SELL"]>;
        amount: z.ZodNumber;
        price: z.ZodNumber;
        remainingAmount: z.ZodNumber;
        sender: z.ZodEffects<z.ZodString, string, string>;
        filledAmount: z.ZodNumber;
        internalOnly: z.ZodBoolean;
        id: z.ZodEffects<z.ZodString, `0x${string}`, string>;
        fee: z.ZodNumber;
        feeAsset: z.ZodString;
        creationTime: z.ZodNumber;
        blockchainOrder: z.ZodObject<{
            id: z.ZodEffects<z.ZodString, `0x${string}`, string>;
            senderAddress: z.ZodEffects<z.ZodString, string, string>;
            matcherAddress: z.ZodEffects<z.ZodString, string, string>;
            baseAsset: z.ZodEffects<z.ZodString, string, string>;
            quoteAsset: z.ZodEffects<z.ZodString, string, string>;
            matcherFeeAsset: z.ZodEffects<z.ZodString, string, string>;
            amount: z.ZodNumber;
            price: z.ZodNumber;
            matcherFee: z.ZodNumber;
            nonce: z.ZodNumber;
            expiration: z.ZodNumber;
            buySide: z.ZodUnion<[z.ZodLiteral<1>, z.ZodLiteral<0>]>;
            signature: z.ZodNullable<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
            isPersonalSign: z.ZodBoolean;
            needWithdraw: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            amount: number;
            id: `0x${string}`;
            price: number;
            expiration: number;
            signature: `0x${string}` | null;
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            matcherFee: number;
            nonce: number;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            needWithdraw: boolean;
        }, {
            amount: number;
            id: string;
            price: number;
            expiration: number;
            signature: string | null;
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            matcherFee: number;
            nonce: number;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            needWithdraw: boolean;
        }>;
        subOrders: z.ZodRecord<z.ZodString, z.ZodObject<{
            assetPair: z.ZodString;
            side: z.ZodEnum<["BUY", "SELL"]>;
            amount: z.ZodNumber;
            remainingAmount: z.ZodNumber;
            sender: z.ZodEffects<z.ZodString, string, string>;
            filledAmount: z.ZodNumber;
            internalOnly: z.ZodBoolean;
            price: z.ZodNumber;
            id: z.ZodNumber;
            parentOrderId: z.ZodEffects<z.ZodString, `0x${string}`, string>;
            exchange: z.ZodString;
            exchanges: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            brokerAddress: z.ZodUnion<[z.ZodUnion<[z.ZodEnum<["INTERNAL_BROKER", "ORION_BROKER", "SELF_BROKER"]>, z.ZodType<"SELF_BROKER_ASCENDEX" | "SELF_BROKER_OKX" | "SELF_BROKER_BINANCE" | "SELF_BROKER_KUCOIN" | "SELF_BROKER_ORION" | "SELF_BROKER_INTERNAL_ORDER_BOOK" | "SELF_BROKER_SPOOKYSWAP" | "SELF_BROKER_PANCAKESWAP" | "SELF_BROKER_UNISWAP" | "SELF_BROKER_QUICKSWAP" | "SELF_BROKER_ORION_POOL" | "SELF_BROKER_INTERNAL_POOL_V2" | "SELF_BROKER_INTERNAL_POOL_V3" | "SELF_BROKER_INTERNAL_POOL_V3_0_01" | "SELF_BROKER_INTERNAL_POOL_V3_0_05" | "SELF_BROKER_INTERNAL_POOL_V3_0_3" | "SELF_BROKER_INTERNAL_POOL_V3_1_0" | "SELF_BROKER_CHERRYSWAP" | "SELF_BROKER_OKXSWAP" | "SELF_BROKER_CURVE" | "SELF_BROKER_CURVE_FACTORY" | "SELF_BROKER_THENA_ALGEBRA_V1", z.ZodTypeDef, "SELF_BROKER_ASCENDEX" | "SELF_BROKER_OKX" | "SELF_BROKER_BINANCE" | "SELF_BROKER_KUCOIN" | "SELF_BROKER_ORION" | "SELF_BROKER_INTERNAL_ORDER_BOOK" | "SELF_BROKER_SPOOKYSWAP" | "SELF_BROKER_PANCAKESWAP" | "SELF_BROKER_UNISWAP" | "SELF_BROKER_QUICKSWAP" | "SELF_BROKER_ORION_POOL" | "SELF_BROKER_INTERNAL_POOL_V2" | "SELF_BROKER_INTERNAL_POOL_V3" | "SELF_BROKER_INTERNAL_POOL_V3_0_01" | "SELF_BROKER_INTERNAL_POOL_V3_0_05" | "SELF_BROKER_INTERNAL_POOL_V3_0_3" | "SELF_BROKER_INTERNAL_POOL_V3_1_0" | "SELF_BROKER_CHERRYSWAP" | "SELF_BROKER_OKXSWAP" | "SELF_BROKER_CURVE" | "SELF_BROKER_CURVE_FACTORY" | "SELF_BROKER_THENA_ALGEBRA_V1">]>, z.ZodEffects<z.ZodString, string, string>]>;
            tradesInfo: z.ZodRecord<z.ZodString, z.ZodObject<{
                tradeId: z.ZodString;
                tradeStatus: z.ZodEnum<["NEW", "PENDING", "OK", "FAIL", "TEMP_ERROR", "REJECTED"]>;
                filledAmount: z.ZodNumber;
                price: z.ZodNumber;
                creationTime: z.ZodNumber;
                updateTime: z.ZodNumber;
                matchedBlockchainOrder: z.ZodOptional<z.ZodObject<{
                    id: z.ZodEffects<z.ZodString, `0x${string}`, string>;
                    senderAddress: z.ZodEffects<z.ZodString, string, string>;
                    matcherAddress: z.ZodEffects<z.ZodString, string, string>;
                    baseAsset: z.ZodEffects<z.ZodString, string, string>;
                    quoteAsset: z.ZodEffects<z.ZodString, string, string>;
                    matcherFeeAsset: z.ZodEffects<z.ZodString, string, string>;
                    amount: z.ZodNumber;
                    price: z.ZodNumber;
                    matcherFee: z.ZodNumber;
                    nonce: z.ZodNumber;
                    expiration: z.ZodNumber;
                    buySide: z.ZodUnion<[z.ZodLiteral<1>, z.ZodLiteral<0>]>;
                    signature: z.ZodNullable<z.ZodEffects<z.ZodString, `0x${string}`, string>>;
                    isPersonalSign: z.ZodBoolean;
                    needWithdraw: z.ZodBoolean;
                }, "strip", z.ZodTypeAny, {
                    amount: number;
                    id: `0x${string}`;
                    price: number;
                    expiration: number;
                    signature: `0x${string}` | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                }, {
                    amount: number;
                    id: string;
                    price: number;
                    expiration: number;
                    signature: string | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                }>>;
                matchedSubOrderId: z.ZodOptional<z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: `0x${string}`;
                    price: number;
                    expiration: number;
                    signature: `0x${string}` | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: string;
                    price: number;
                    expiration: number;
                    signature: string | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>>;
            status: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND"]>;
            complexSwap: z.ZodBoolean;
        }, "strip", z.ZodTypeAny, {
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            id: number;
            price: number;
            brokerAddress: string;
            exchange: string;
            remainingAmount: number;
            sender: string;
            filledAmount: number;
            internalOnly: boolean;
            parentOrderId: `0x${string}`;
            tradesInfo: Record<string, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: `0x${string}`;
                    price: number;
                    expiration: number;
                    signature: `0x${string}` | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>;
            complexSwap: boolean;
            exchanges?: string[] | undefined;
        }, {
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            id: number;
            price: number;
            brokerAddress: string;
            exchange: string;
            remainingAmount: number;
            sender: string;
            filledAmount: number;
            internalOnly: boolean;
            parentOrderId: string;
            tradesInfo: Record<string, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: string;
                    price: number;
                    expiration: number;
                    signature: string | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>;
            complexSwap: boolean;
            exchanges?: string[] | undefined;
        }>>;
        updateTime: z.ZodNumber;
        status: z.ZodEnum<["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"]>;
        settledAmount: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        id: `0x${string}`;
        price: number;
        remainingAmount: number;
        sender: string;
        settledAmount: number;
        subOrders: Record<string, {
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            id: number;
            price: number;
            brokerAddress: string;
            exchange: string;
            remainingAmount: number;
            sender: string;
            filledAmount: number;
            internalOnly: boolean;
            parentOrderId: `0x${string}`;
            tradesInfo: Record<string, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: `0x${string}`;
                    price: number;
                    expiration: number;
                    signature: `0x${string}` | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>;
            complexSwap: boolean;
            exchanges?: string[] | undefined;
        }>;
        feeAsset: string;
        fee: number;
        creationTime: number;
        filledAmount: number;
        updateTime: number;
        internalOnly: boolean;
        blockchainOrder: {
            amount: number;
            id: `0x${string}`;
            price: number;
            expiration: number;
            signature: `0x${string}` | null;
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            matcherFee: number;
            nonce: number;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            needWithdraw: boolean;
        };
    }, {
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        id: string;
        price: number;
        remainingAmount: number;
        sender: string;
        settledAmount: number;
        subOrders: Record<string, {
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            id: number;
            price: number;
            brokerAddress: string;
            exchange: string;
            remainingAmount: number;
            sender: string;
            filledAmount: number;
            internalOnly: boolean;
            parentOrderId: string;
            tradesInfo: Record<string, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: string;
                    price: number;
                    expiration: number;
                    signature: string | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>;
            complexSwap: boolean;
            exchanges?: string[] | undefined;
        }>;
        feeAsset: string;
        fee: number;
        creationTime: number;
        filledAmount: number;
        updateTime: number;
        internalOnly: boolean;
        blockchainOrder: {
            amount: number;
            id: string;
            price: number;
            expiration: number;
            signature: string | null;
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            matcherFee: number;
            nonce: number;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            needWithdraw: boolean;
        };
    }>;
}, "strip", z.ZodTypeAny, {
    orderId: `0x${string}`;
    order: {
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        id: `0x${string}`;
        price: number;
        remainingAmount: number;
        sender: string;
        settledAmount: number;
        subOrders: Record<string, {
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            id: number;
            price: number;
            brokerAddress: string;
            exchange: string;
            remainingAmount: number;
            sender: string;
            filledAmount: number;
            internalOnly: boolean;
            parentOrderId: `0x${string}`;
            tradesInfo: Record<string, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: `0x${string}`;
                    price: number;
                    expiration: number;
                    signature: `0x${string}` | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>;
            complexSwap: boolean;
            exchanges?: string[] | undefined;
        }>;
        feeAsset: string;
        fee: number;
        creationTime: number;
        filledAmount: number;
        updateTime: number;
        internalOnly: boolean;
        blockchainOrder: {
            amount: number;
            id: `0x${string}`;
            price: number;
            expiration: number;
            signature: `0x${string}` | null;
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            matcherFee: number;
            nonce: number;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            needWithdraw: boolean;
        };
    };
}, {
    orderId: string;
    order: {
        status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
        assetPair: string;
        side: "BUY" | "SELL";
        amount: number;
        id: string;
        price: number;
        remainingAmount: number;
        sender: string;
        settledAmount: number;
        subOrders: Record<string, {
            status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
            assetPair: string;
            side: "BUY" | "SELL";
            amount: number;
            id: number;
            price: number;
            brokerAddress: string;
            exchange: string;
            remainingAmount: number;
            sender: string;
            filledAmount: number;
            internalOnly: boolean;
            parentOrderId: string;
            tradesInfo: Record<string, {
                price: number;
                creationTime: number;
                tradeId: string;
                tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                filledAmount: number;
                updateTime: number;
                matchedBlockchainOrder?: {
                    amount: number;
                    id: string;
                    price: number;
                    expiration: number;
                    signature: string | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                } | undefined;
                matchedSubOrderId?: number | undefined;
            }>;
            complexSwap: boolean;
            exchanges?: string[] | undefined;
        }>;
        feeAsset: string;
        fee: number;
        creationTime: number;
        filledAmount: number;
        updateTime: number;
        internalOnly: boolean;
        blockchainOrder: {
            amount: number;
            id: string;
            price: number;
            expiration: number;
            signature: string | null;
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            matcherFee: number;
            nonce: number;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            needWithdraw: boolean;
        };
    };
}>;

declare const aggregatedOrderbookSchema: z.ZodObject<{
    asks: z.ZodArray<z.ZodObject<{
        path: z.ZodArray<z.ZodObject<{
            assetPair: z.ZodString;
            action: z.ZodEnum<["BUY", "SELL"]>;
        }, "strip", z.ZodTypeAny, {
            assetPair: string;
            action: "BUY" | "SELL";
        }, {
            assetPair: string;
            action: "BUY" | "SELL";
        }>, "many">;
        amount: z.ZodNumber;
        price: z.ZodNumber;
        exchanges: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }>, "many">;
    bids: z.ZodArray<z.ZodObject<{
        path: z.ZodArray<z.ZodObject<{
            assetPair: z.ZodString;
            action: z.ZodEnum<["BUY", "SELL"]>;
        }, "strip", z.ZodTypeAny, {
            assetPair: string;
            action: "BUY" | "SELL";
        }, {
            assetPair: string;
            action: "BUY" | "SELL";
        }>, "many">;
        amount: z.ZodNumber;
        price: z.ZodNumber;
        exchanges: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    asks: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }[];
    bids: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }[];
}, {
    asks: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }[];
    bids: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        exchanges: string[];
        price: number;
    }[];
}>;
declare const exchangeOrderbookSchema: z.ZodObject<{
    asks: z.ZodArray<z.ZodObject<{
        price: z.ZodNumber;
        amount: z.ZodNumber;
        path: z.ZodArray<z.ZodObject<{
            assetPair: z.ZodString;
            action: z.ZodEnum<["BUY", "SELL"]>;
        }, "strip", z.ZodTypeAny, {
            assetPair: string;
            action: "BUY" | "SELL";
        }, {
            assetPair: string;
            action: "BUY" | "SELL";
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }>, "many">;
    bids: z.ZodArray<z.ZodObject<{
        price: z.ZodNumber;
        amount: z.ZodNumber;
        path: z.ZodArray<z.ZodObject<{
            assetPair: z.ZodString;
            action: z.ZodEnum<["BUY", "SELL"]>;
        }, "strip", z.ZodTypeAny, {
            assetPair: string;
            action: "BUY" | "SELL";
        }, {
            assetPair: string;
            action: "BUY" | "SELL";
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }, {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    asks: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }[];
    bids: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }[];
}, {
    asks: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }[];
    bids: {
        path: {
            assetPair: string;
            action: "BUY" | "SELL";
        }[];
        amount: number;
        price: number;
    }[];
}>;
declare const poolReservesSchema: z.ZodObject<{
    a: z.ZodNumber;
    p: z.ZodNumber;
    indicativePrice: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    a: number;
    p: number;
    indicativePrice: number;
}, {
    a: number;
    p: number;
    indicativePrice: number;
}>;

declare const errorSchema$1: z.ZodObject<{
    error: z.ZodObject<{
        code: z.ZodNumber;
        reason: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        code: number;
        reason: string;
    }, {
        code: number;
        reason: string;
    }>;
    timestamp: z.ZodString;
}, "strip", z.ZodTypeAny, {
    error: {
        code: number;
        reason: string;
    };
    timestamp: string;
}, {
    error: {
        code: number;
        reason: string;
    };
    timestamp: string;
}>;

declare const index$i_aggregatedOrderbookSchema: typeof aggregatedOrderbookSchema;
declare const index$i_atomicSwapHistorySchema: typeof atomicSwapHistorySchema;
declare const index$i_cancelOrderSchema: typeof cancelOrderSchema;
declare const index$i_exchangeInfoSchema: typeof exchangeInfoSchema;
declare const index$i_exchangeOrderbookSchema: typeof exchangeOrderbookSchema;
declare const index$i_orderBenefitsSchema: typeof orderBenefitsSchema;
declare const index$i_orderSchema: typeof orderSchema;
declare const index$i_pairConfigSchema: typeof pairConfigSchema;
declare const index$i_placeAtomicSwapSchema: typeof placeAtomicSwapSchema;
declare const index$i_poolReservesSchema: typeof poolReservesSchema;
declare const index$i_redeemOrderSchema: typeof redeemOrderSchema;
declare const index$i_swapInfoSchema: typeof swapInfoSchema;
declare namespace index$i {
    export {
        index$i_aggregatedOrderbookSchema as aggregatedOrderbookSchema,
        index$i_atomicSwapHistorySchema as atomicSwapHistorySchema,
        index$i_cancelOrderSchema as cancelOrderSchema,
        errorSchema$1 as errorSchema,
        index$i_exchangeInfoSchema as exchangeInfoSchema,
        index$i_exchangeOrderbookSchema as exchangeOrderbookSchema,
        index$i_orderBenefitsSchema as orderBenefitsSchema,
        index$i_orderSchema as orderSchema,
        index$i_pairConfigSchema as pairConfigSchema,
        index$i_placeAtomicSwapSchema as placeAtomicSwapSchema,
        index$i_poolReservesSchema as poolReservesSchema,
        index$i_redeemOrderSchema as redeemOrderSchema,
        index$i_swapInfoSchema as swapInfoSchema,
    };
}

declare class Aggregator {
    private readonly apiUrl;
    readonly ws: AggregatorWS;
    private readonly basicAuth?;
    get api(): string;
    logger: ((message: string) => void) | undefined;
    constructor(httpAPIUrl: string, wsAPIUrl: string, basicAuth?: BasicAuthCredentials, logger?: ((message: string) => void) | undefined);
    get basicAuthHeaders(): {
        Authorization: string;
    } | {
        Authorization?: never;
    };
    getOrder: (orderId: string, owner?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            orderId: `0x${string}`;
            order: {
                status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                id: `0x${string}`;
                price: number;
                remainingAmount: number;
                sender: string;
                settledAmount: number;
                subOrders: Record<string, {
                    status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    id: number;
                    price: number;
                    brokerAddress: string;
                    exchange: string;
                    remainingAmount: number;
                    sender: string;
                    filledAmount: number;
                    internalOnly: boolean;
                    parentOrderId: `0x${string}`;
                    tradesInfo: Record<string, {
                        price: number;
                        creationTime: number;
                        tradeId: string;
                        tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                        filledAmount: number;
                        updateTime: number;
                        matchedBlockchainOrder?: {
                            amount: number;
                            id: `0x${string}`;
                            price: number;
                            expiration: number;
                            signature: `0x${string}` | null;
                            senderAddress: string;
                            matcherAddress: string;
                            baseAsset: string;
                            quoteAsset: string;
                            matcherFeeAsset: string;
                            matcherFee: number;
                            nonce: number;
                            buySide: 0 | 1;
                            isPersonalSign: boolean;
                            needWithdraw: boolean;
                        } | undefined;
                        matchedSubOrderId?: number | undefined;
                    }>;
                    complexSwap: boolean;
                    exchanges?: string[] | undefined;
                }>;
                feeAsset: string;
                fee: number;
                creationTime: number;
                filledAmount: number;
                updateTime: number;
                internalOnly: boolean;
                blockchainOrder: {
                    amount: number;
                    id: `0x${string}`;
                    price: number;
                    expiration: number;
                    signature: `0x${string}` | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                };
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            orderId: string;
            order: {
                status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND" | "ROUTING";
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                id: string;
                price: number;
                remainingAmount: number;
                sender: string;
                settledAmount: number;
                subOrders: Record<string, {
                    status: "NEW" | "ACCEPTED" | "PARTIALLY_FILLED" | "FILLED" | "TX_PENDING" | "CANCELED" | "REJECTED" | "FAILED" | "SETTLED" | "NOT_FOUND";
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    id: number;
                    price: number;
                    brokerAddress: string;
                    exchange: string;
                    remainingAmount: number;
                    sender: string;
                    filledAmount: number;
                    internalOnly: boolean;
                    parentOrderId: string;
                    tradesInfo: Record<string, {
                        price: number;
                        creationTime: number;
                        tradeId: string;
                        tradeStatus: "NEW" | "REJECTED" | "PENDING" | "OK" | "FAIL" | "TEMP_ERROR";
                        filledAmount: number;
                        updateTime: number;
                        matchedBlockchainOrder?: {
                            amount: number;
                            id: string;
                            price: number;
                            expiration: number;
                            signature: string | null;
                            senderAddress: string;
                            matcherAddress: string;
                            baseAsset: string;
                            quoteAsset: string;
                            matcherFeeAsset: string;
                            matcherFee: number;
                            nonce: number;
                            buySide: 0 | 1;
                            isPersonalSign: boolean;
                            needWithdraw: boolean;
                        } | undefined;
                        matchedSubOrderId?: number | undefined;
                    }>;
                    complexSwap: boolean;
                    exchanges?: string[] | undefined;
                }>;
                feeAsset: string;
                fee: number;
                creationTime: number;
                filledAmount: number;
                updateTime: number;
                internalOnly: boolean;
                blockchainOrder: {
                    amount: number;
                    id: string;
                    price: number;
                    expiration: number;
                    signature: string | null;
                    senderAddress: string;
                    matcherAddress: string;
                    baseAsset: string;
                    quoteAsset: string;
                    matcherFeeAsset: string;
                    matcherFee: number;
                    nonce: number;
                    buySide: 0 | 1;
                    isPersonalSign: boolean;
                    needWithdraw: boolean;
                };
            };
        }>;
    }>>;
    getPairsList: (market: 'spot') => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string[]>;
    }>>;
    getAggregatedOrderbook: (pair: string, depth?: number) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            asks: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                exchanges: string[];
                price: number;
            }[];
            bids: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                exchanges: string[];
                price: number;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            asks: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                exchanges: string[];
                price: number;
            }[];
            bids: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                exchanges: string[];
                price: number;
            }[];
        }>;
    }>>;
    getAvailableExchanges: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string[]>;
    }>>;
    getExchangeOrderbook: (pair: string, exchange: string, depth?: number, filterByBrokerBalances?: boolean | null) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            asks: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                price: number;
            }[];
            bids: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                price: number;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            asks: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                price: number;
            }[];
            bids: {
                path: {
                    assetPair: string;
                    action: "BUY" | "SELL";
                }[];
                amount: number;
                price: number;
            }[];
        }>;
    }>>;
    getPairConfigs: (market: 'spot') => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            name: string;
            maxPrice: number;
            maxQty: number;
            minPrice: number;
            minQty: number;
            pricePrecision: number;
            qtyPrecision: number;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            name: string;
            maxPrice: number;
            maxQty: number;
            minPrice: number;
            minQty: number;
            pricePrecision: number;
            qtyPrecision: number;
        }[]>;
    }>>;
    getPoolReserves: (pair: string, exchange: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            a: number;
            p: number;
            indicativePrice: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            a: number;
            p: number;
            indicativePrice: number;
        }>;
    }>>;
    getVersion: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            version: string;
            serviceName: string;
            apiVersion: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            version: string;
            serviceName: string;
            apiVersion: string;
        }>;
    }>>;
    getPairConfig: (assetPair: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            name: string;
            maxPrice: number;
            maxQty: number;
            minPrice: number;
            minQty: number;
            pricePrecision: number;
            qtyPrecision: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            name: string;
            maxPrice: number;
            maxQty: number;
            minPrice: number;
            minQty: number;
            pricePrecision: number;
            qtyPrecision: number;
        }>;
    }>>;
    checkWhitelisted: (address: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: boolean;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<boolean>;
    }>>;
    placeOrder: (signedOrder: SignedOrder, isCreateInternalOrder: boolean, isReversedOrder?: boolean, partnerId?: string, source?: OrderSource, rawExchangeRestrictions?: string | undefined) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            orderId: string;
            placementRequests?: {
                amount: number;
                brokerAddress: string;
                exchange: string;
            }[] | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            orderId: string;
            placementRequests?: {
                amount: number;
                brokerAddress: string;
                exchange: string;
            }[] | undefined;
        }>;
    }>>;
    cancelOrder: (signedCancelOrderRequest: SignedCancelOrderRequest) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            orderId: string | number;
            cancellationRequests?: {
                amount: number;
                brokerAddress: string;
                exchange: string;
            }[] | undefined;
            remainingAmount?: number | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            orderId: string | number;
            cancellationRequests?: {
                amount: number;
                brokerAddress: string;
                exchange: string;
            }[] | undefined;
            remainingAmount?: number | undefined;
        }>;
    }>>;
    getSwapInfo: (type: 'exactSpend' | 'exactReceive', assetIn: string, assetOut: string, amount: string, instantSettlement?: boolean, exchanges?: string[] | 'cex' | 'pools') => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            type: "exactSpend";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: number | null;
            marketAmountIn: null;
            availableAmountIn: number;
            availableAmountOut: null;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        } | {
            type: "exactReceive";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: null;
            marketAmountIn: number | null;
            availableAmountIn: null;
            availableAmountOut: number;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: number | null;
            marketAmountIn: null;
            availableAmountIn: number;
            availableAmountOut: null;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        } | {
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: null;
            marketAmountIn: number | null;
            availableAmountIn: null;
            availableAmountOut: number;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        }>;
    }>>;
    getPrices: (assetPair: string, includePools: boolean) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: number;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<number>;
    }>>;
    getLockedBalance: (address: string, currency: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            [x: string]: number | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            [x: string]: number | undefined;
        }>;
    }>>;
    getTradeProfits: (symbol: string, amount: BigNumber, isBuy: boolean) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Record<string, {
            benefitBtc: string;
            benefitPct: string;
        }>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, {
            benefitBtc: string;
            benefitPct: string;
        }>>;
    }>>;
    getStableCoins: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string[]>;
    }>>;
    /**
     * Placing atomic swap. Placement must take place on the target chain.
     * @param secretHash Secret hash
     * @param sourceNetworkCode uppercase, e.g. BSC, ETH
     * @returns Fetch promise
     */
    placeAtomicSwap: (secretHash: string, sourceNetworkCode: Uppercase<(typeof _default$3)[number]>) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            redeemOrder: {
                amount: number;
                asset: string;
                expiration: number;
                receiver: string;
                secretHash: string;
                sender: string;
                signature: string;
                claimReceiver: string;
            };
            secretHash: string;
            sender: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            redeemOrder: {
                amount: number;
                asset: string;
                expiration: number;
                receiver: string;
                secretHash: string;
                sender: string;
                signature: string;
                claimReceiver: string;
            };
            secretHash: string;
            sender: string;
        }>;
    }>>;
    /**
     * Get placed atomic swaps. Each atomic swap received from this list has a target chain corresponding to this Aggregator
     * @param sender Sender address
     * @returns Fetch promise
     */
    getHistoryAtomicSwaps: (sender: string, limit?: number) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            status: "SETTLED" | "EXPIRED" | "ACTIVE";
            id: string;
            redeemOrder: {
                amount: number;
                asset: string;
                expiration: number;
                receiver: string;
                secretHash: string;
                sender: string;
                signature: string;
                claimReceiver: string;
            };
            sender: string;
            lockOrder: {
                amount: number;
                asset: string;
                expiration: number;
                secretHash: string;
                sender: string;
                used: boolean;
                sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
            };
            creationTime: number;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            status: "SETTLED" | "EXPIRED" | "ACTIVE";
            id: string;
            redeemOrder: {
                amount: number;
                asset: string;
                expiration: number;
                receiver: string;
                secretHash: string;
                sender: string;
                signature: string;
                claimReceiver: string;
            };
            sender: string;
            lockOrder: {
                amount: number;
                asset: string;
                expiration: number;
                secretHash: string;
                sender: string;
                used: boolean;
                sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
            };
            creationTime: number;
        }[]>;
    }>>;
    getIsCexLiquidityAvailable: (assetIn: string, assetOut: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            error: {
                code: number;
                reason: string;
            };
            timestamp: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: boolean;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<boolean>;
    }>>;
    private sign;
    private generateHeaders;
    RFQOrder(tokenFrom: string, tokenTo: string, fromTokenAmount: string, apiKey: string, //
             secretKey: string, wallet: string): Promise<z.infer<typeof pmmOrderSchema>>;
}

type index$h_Aggregator = Aggregator;
declare const index$h_Aggregator: typeof Aggregator;
declare namespace index$h {
    export {
        index$h_Aggregator as Aggregator,
        index$i as schemas,
        index$j as ws,
    };
}

declare enum PairStatusEnum {
    DOESNT_EXIST = -1,
    REVIEW = 0,
    ACCEPTED = 1,
    REJECTED = 2
}
declare const pairStatusSchema: z.ZodNativeEnum<typeof PairStatusEnum>;
declare const poolOnVerificationSchema: z.ZodObject<{
    tokenA: z.ZodObject<{
        symbol: z.ZodString;
        icon: z.ZodOptional<z.ZodString>;
        address: z.ZodString;
        decimals: z.ZodOptional<z.ZodNumber>;
        isUser: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }>;
    tokenB: z.ZodObject<{
        symbol: z.ZodString;
        icon: z.ZodOptional<z.ZodString>;
        address: z.ZodString;
        decimals: z.ZodOptional<z.ZodNumber>;
        isUser: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }>;
    _id: z.ZodOptional<z.ZodString>;
    address: z.ZodString;
    symbol: z.ZodString;
    isUser: z.ZodBoolean;
    minQty: z.ZodOptional<z.ZodNumber>;
    tokensReversed: z.ZodBoolean;
    status: z.ZodNativeEnum<typeof PairStatusEnum>;
    updatedAt: z.ZodNumber;
    createdAt: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    symbol: string;
    status: PairStatusEnum;
    address: string;
    isUser: boolean;
    tokenA: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokenB: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokensReversed: boolean;
    updatedAt: number;
    createdAt: number;
    _id?: string | undefined;
    minQty?: number | undefined;
}, {
    symbol: string;
    status: PairStatusEnum;
    address: string;
    isUser: boolean;
    tokenA: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokenB: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokensReversed: boolean;
    updatedAt: number;
    createdAt: number;
    _id?: string | undefined;
    minQty?: number | undefined;
}>;
type adminPoolType = z.infer<typeof poolOnVerificationSchema>;
declare const adminPoolSchema: z.ZodObject<{
    tokenA: z.ZodObject<{
        symbol: z.ZodString;
        icon: z.ZodOptional<z.ZodString>;
        address: z.ZodString;
        decimals: z.ZodOptional<z.ZodNumber>;
        isUser: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }>;
    tokenB: z.ZodObject<{
        symbol: z.ZodString;
        icon: z.ZodOptional<z.ZodString>;
        address: z.ZodString;
        decimals: z.ZodOptional<z.ZodNumber>;
        isUser: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }>;
    _id: z.ZodOptional<z.ZodString>;
    address: z.ZodString;
    symbol: z.ZodString;
    isUser: z.ZodBoolean;
    minQty: z.ZodOptional<z.ZodNumber>;
    tokensReversed: z.ZodBoolean;
    status: z.ZodNativeEnum<typeof PairStatusEnum>;
    updatedAt: z.ZodNumber;
    createdAt: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    symbol: string;
    status: PairStatusEnum;
    address: string;
    isUser: boolean;
    tokenA: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokenB: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokensReversed: boolean;
    updatedAt: number;
    createdAt: number;
    _id?: string | undefined;
    minQty?: number | undefined;
}, {
    symbol: string;
    status: PairStatusEnum;
    address: string;
    isUser: boolean;
    tokenA: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokenB: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokensReversed: boolean;
    updatedAt: number;
    createdAt: number;
    _id?: string | undefined;
    minQty?: number | undefined;
}>;

declare const _default$2: z.ZodArray<z.ZodObject<{
    tokenA: z.ZodObject<{
        symbol: z.ZodString;
        icon: z.ZodOptional<z.ZodString>;
        address: z.ZodString;
        decimals: z.ZodOptional<z.ZodNumber>;
        isUser: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }>;
    tokenB: z.ZodObject<{
        symbol: z.ZodString;
        icon: z.ZodOptional<z.ZodString>;
        address: z.ZodString;
        decimals: z.ZodOptional<z.ZodNumber>;
        isUser: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }, {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    }>;
    _id: z.ZodOptional<z.ZodString>;
    address: z.ZodString;
    symbol: z.ZodString;
    isUser: z.ZodBoolean;
    minQty: z.ZodOptional<z.ZodNumber>;
    tokensReversed: z.ZodBoolean;
    status: z.ZodNativeEnum<typeof PairStatusEnum>;
    updatedAt: z.ZodNumber;
    createdAt: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    symbol: string;
    status: PairStatusEnum;
    address: string;
    isUser: boolean;
    tokenA: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokenB: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokensReversed: boolean;
    updatedAt: number;
    createdAt: number;
    _id?: string | undefined;
    minQty?: number | undefined;
}, {
    symbol: string;
    status: PairStatusEnum;
    address: string;
    isUser: boolean;
    tokenA: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokenB: {
        symbol: string;
        address: string;
        icon?: string | undefined;
        decimals?: number | undefined;
        isUser?: boolean | undefined;
    };
    tokensReversed: boolean;
    updatedAt: number;
    createdAt: number;
    _id?: string | undefined;
    minQty?: number | undefined;
}>, "many">;

declare const addPoolSchema: z.ZodObject<{
    poolAddress: z.ZodString;
    tokenAIcon: z.ZodOptional<z.ZodString>;
    tokenAName: z.ZodOptional<z.ZodString>;
    tokenBIcon: z.ZodOptional<z.ZodString>;
    tokenBName: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    poolAddress: string;
    tokenAIcon?: string | undefined;
    tokenAName?: string | undefined;
    tokenBIcon?: string | undefined;
    tokenBName?: string | undefined;
}, {
    poolAddress: string;
    tokenAIcon?: string | undefined;
    tokenAName?: string | undefined;
    tokenBIcon?: string | undefined;
    tokenBName?: string | undefined;
}>;

declare const atomicHistorySchema: z.ZodObject<{
    success: z.ZodBoolean;
    count: z.ZodNumber;
    total: z.ZodNumber;
    pagination: z.ZodObject<{}, "strip", z.ZodTypeAny, {}, {}>;
    data: z.ZodEffects<z.ZodArray<z.ZodUnknown, "many">, ({
        type: "source";
        asset: string;
        secretHash: `0x${string}`;
        sender: string;
        used: boolean;
        _id: string;
        claimed: boolean;
        isAggApplied: boolean;
        __v: number;
        targetChainId: number;
        receiver?: string | undefined;
        secret?: string | undefined;
        amountToReceive?: number | undefined;
        amountToSpend?: number | undefined;
        timestamp?: {
            lock?: number | undefined;
            claim?: number | undefined;
            refund?: number | undefined;
        } | undefined;
        expiration?: {
            lock?: number | undefined;
        } | undefined;
        state?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
        transactions?: {
            lock?: string | undefined;
            claim?: string | undefined;
            refund?: string | undefined;
        } | undefined;
    } | {
        type: "target";
        asset: string;
        secretHash: `0x${string}`;
        sender: string;
        used: boolean;
        _id: string;
        claimed: boolean;
        isAggApplied: boolean;
        __v: number;
        receiver?: string | undefined;
        secret?: string | undefined;
        timestamp?: {
            redeem?: number | undefined;
        } | undefined;
        expiration?: {
            redeem?: number | undefined;
        } | undefined;
        state?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
        transactions?: {
            redeem?: string | undefined;
        } | undefined;
    })[], unknown[]>;
}, "strip", z.ZodTypeAny, {
    data: ({
        type: "source";
        asset: string;
        secretHash: `0x${string}`;
        sender: string;
        used: boolean;
        _id: string;
        claimed: boolean;
        isAggApplied: boolean;
        __v: number;
        targetChainId: number;
        receiver?: string | undefined;
        secret?: string | undefined;
        amountToReceive?: number | undefined;
        amountToSpend?: number | undefined;
        timestamp?: {
            lock?: number | undefined;
            claim?: number | undefined;
            refund?: number | undefined;
        } | undefined;
        expiration?: {
            lock?: number | undefined;
        } | undefined;
        state?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
        transactions?: {
            lock?: string | undefined;
            claim?: string | undefined;
            refund?: string | undefined;
        } | undefined;
    } | {
        type: "target";
        asset: string;
        secretHash: `0x${string}`;
        sender: string;
        used: boolean;
        _id: string;
        claimed: boolean;
        isAggApplied: boolean;
        __v: number;
        receiver?: string | undefined;
        secret?: string | undefined;
        timestamp?: {
            redeem?: number | undefined;
        } | undefined;
        expiration?: {
            redeem?: number | undefined;
        } | undefined;
        state?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
        transactions?: {
            redeem?: string | undefined;
        } | undefined;
    })[];
    success: boolean;
    count: number;
    total: number;
    pagination: {};
}, {
    data: unknown[];
    success: boolean;
    count: number;
    total: number;
    pagination: {};
}>;

declare const checkRedeemOrderSchema: z.ZodObject<{
    redeemTxHash: z.ZodString;
    secret: z.ZodNullable<z.ZodString>;
    secretHash: z.ZodString;
}, "strip", z.ZodTypeAny, {
    secretHash: string;
    secret: string | null;
    redeemTxHash: string;
}, {
    secretHash: string;
    secret: string | null;
    redeemTxHash: string;
}>;

declare const historySchema: z.ZodEffects<z.ZodArray<z.ZodObject<{
    amount: z.ZodString;
    amountNumber: z.ZodString;
    asset: z.ZodString;
    assetAddress: z.ZodString;
    contractBalance: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    createdAt: z.ZodNumber;
    transactionHash: z.ZodString;
    type: z.ZodEnum<["deposit", "withdrawal"]>;
    user: z.ZodString;
    walletBalance: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    type: "deposit" | "withdrawal";
    amount: string;
    asset: string;
    createdAt: number;
    amountNumber: string;
    assetAddress: string;
    transactionHash: string;
    user: string;
    contractBalance?: string | null | undefined;
    walletBalance?: string | null | undefined;
}, {
    type: "deposit" | "withdrawal";
    amount: string;
    asset: string;
    createdAt: number;
    amountNumber: string;
    assetAddress: string;
    transactionHash: string;
    user: string;
    contractBalance?: string | null | undefined;
    walletBalance?: string | null | undefined;
}>, "many">, {
    type: "deposit" | "withdrawal";
    date: number;
    token: string;
    amount: string;
    status: HistoryTransactionStatus;
    transactionHash: string;
    user: string;
}[], {
    type: "deposit" | "withdrawal";
    amount: string;
    asset: string;
    createdAt: number;
    amountNumber: string;
    assetAddress: string;
    transactionHash: string;
    user: string;
    contractBalance?: string | null | undefined;
    walletBalance?: string | null | undefined;
}[]>;

declare const IDOSchema: z.ZodObject<{
    amount: z.ZodUnion<[z.ZodNumber, z.ZodNull]>;
    amountInWei: z.ZodUnion<[z.ZodNumber, z.ZodNull]>;
    amountInUSDT: z.ZodUnion<[z.ZodNumber, z.ZodNull]>;
    address: z.ZodString;
}, "strip", z.ZodTypeAny, {
    amount: number | null;
    address: string;
    amountInWei: number | null;
    amountInUSDT: number | null;
}, {
    amount: number | null;
    address: string;
    amountInWei: number | null;
    amountInUSDT: number | null;
}>;

declare const infoSchema: z.ZodObject<{
    chainId: z.ZodNumber;
    chainName: z.ZodString;
    exchangeContractAddress: z.ZodString;
    swapExecutorContractAddress: z.ZodString;
    oracleContractAddress: z.ZodString;
    matcherAddress: z.ZodString;
    orderFeePercent: z.ZodNumber;
    assetToAddress: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodString>, Partial<Record<string, string>>, Record<string, string>>;
    assetToDecimals: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodNumber>, Partial<Record<string, number>>, Record<string, number>>;
    assetToIcons: z.ZodOptional<z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodString>, Partial<Record<string, string>>, Record<string, string>>>;
    cexTokens: z.ZodArray<z.ZodString, "many">;
    internalFeeAssets: z.ZodOptional<z.ZodArray<z.ZodObject<{
        type: z.ZodEnum<["percent", "plain"]>;
        value: z.ZodNumber;
        asset: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "percent" | "plain";
        value: number;
        asset: string;
    }, {
        type: "percent" | "plain";
        value: number;
        asset: string;
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    chainId: number;
    matcherAddress: string;
    chainName: string;
    exchangeContractAddress: string;
    swapExecutorContractAddress: string;
    oracleContractAddress: string;
    orderFeePercent: number;
    assetToAddress: Partial<Record<string, string>>;
    assetToDecimals: Partial<Record<string, number>>;
    cexTokens: string[];
    assetToIcons?: Partial<Record<string, string>> | undefined;
    internalFeeAssets?: {
        type: "percent" | "plain";
        value: number;
        asset: string;
    }[] | undefined;
}, {
    chainId: number;
    matcherAddress: string;
    chainName: string;
    exchangeContractAddress: string;
    swapExecutorContractAddress: string;
    oracleContractAddress: string;
    orderFeePercent: number;
    assetToAddress: Record<string, string>;
    assetToDecimals: Record<string, number>;
    cexTokens: string[];
    assetToIcons?: Record<string, string> | undefined;
    internalFeeAssets?: {
        type: "percent" | "plain";
        value: number;
        asset: string;
    }[] | undefined;
}>;

declare const poolsConfigSchema: z.ZodObject<{
    WETHAddress: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    factoryAddress: z.ZodEffects<z.ZodString, string, string>;
    governanceAddress: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    routerAddress: z.ZodEffects<z.ZodString, string, string>;
    votingAddress: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    factories: z.ZodOptional<z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodEffects<z.ZodString, string, string>>, Partial<Record<string, string>>, Record<string, string>>>;
    pools: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodObject<{
        lpTokenAddress: z.ZodEffects<z.ZodString, string, string>;
        minQty: z.ZodOptional<z.ZodNumber>;
        reverted: z.ZodOptional<z.ZodBoolean>;
        rewardToken: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        state: z.ZodOptional<z.ZodNumber>;
        rewardTokenDecimals: z.ZodOptional<z.ZodNumber>;
        stakingRewardFinish: z.ZodOptional<z.ZodNumber>;
        stakingRewardAddress: z.ZodEffects<z.ZodString, string, string>;
        vote_rewards_disabled: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        lpTokenAddress: string;
        stakingRewardAddress: string;
        minQty?: number | undefined;
        reverted?: boolean | undefined;
        rewardToken?: string | null | undefined;
        state?: number | undefined;
        rewardTokenDecimals?: number | undefined;
        stakingRewardFinish?: number | undefined;
        vote_rewards_disabled?: boolean | undefined;
    }, {
        lpTokenAddress: string;
        stakingRewardAddress: string;
        minQty?: number | undefined;
        reverted?: boolean | undefined;
        rewardToken?: string | null | undefined;
        state?: number | undefined;
        rewardTokenDecimals?: number | undefined;
        stakingRewardFinish?: number | undefined;
        vote_rewards_disabled?: boolean | undefined;
    }>>, Partial<Record<string, {
        lpTokenAddress: string;
        stakingRewardAddress: string;
        minQty?: number | undefined;
        reverted?: boolean | undefined;
        rewardToken?: string | null | undefined;
        state?: number | undefined;
        rewardTokenDecimals?: number | undefined;
        stakingRewardFinish?: number | undefined;
        vote_rewards_disabled?: boolean | undefined;
    }>>, Record<string, {
        lpTokenAddress: string;
        stakingRewardAddress: string;
        minQty?: number | undefined;
        reverted?: boolean | undefined;
        rewardToken?: string | null | undefined;
        state?: number | undefined;
        rewardTokenDecimals?: number | undefined;
        stakingRewardFinish?: number | undefined;
        vote_rewards_disabled?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    pools: Partial<Record<string, {
        lpTokenAddress: string;
        stakingRewardAddress: string;
        minQty?: number | undefined;
        reverted?: boolean | undefined;
        rewardToken?: string | null | undefined;
        state?: number | undefined;
        rewardTokenDecimals?: number | undefined;
        stakingRewardFinish?: number | undefined;
        vote_rewards_disabled?: boolean | undefined;
    }>>;
    factoryAddress: string;
    routerAddress: string;
    WETHAddress?: string | undefined;
    governanceAddress?: string | undefined;
    votingAddress?: string | undefined;
    factories?: Partial<Record<string, string>> | undefined;
}, {
    pools: Record<string, {
        lpTokenAddress: string;
        stakingRewardAddress: string;
        minQty?: number | undefined;
        reverted?: boolean | undefined;
        rewardToken?: string | null | undefined;
        state?: number | undefined;
        rewardTokenDecimals?: number | undefined;
        stakingRewardFinish?: number | undefined;
        vote_rewards_disabled?: boolean | undefined;
    }>;
    factoryAddress: string;
    routerAddress: string;
    WETHAddress?: string | undefined;
    governanceAddress?: string | undefined;
    votingAddress?: string | undefined;
    factories?: Record<string, string> | undefined;
}>;

declare const poolsInfoSchema: z.ZodObject<{
    governance: z.ZodObject<{
        apr: z.ZodString;
        rewardRate: z.ZodString;
        totalBalance: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        apr: string;
        rewardRate: string;
        totalBalance: string;
    }, {
        apr: string;
        rewardRate: string;
        totalBalance: string;
    }>;
    totalRewardRatePerWeek: z.ZodString;
    pools: z.ZodRecord<z.ZodString, z.ZodObject<{
        currentAPR: z.ZodString;
        isUser: z.ZodOptional<z.ZodBoolean>;
        price: z.ZodString;
        reserves: z.ZodRecord<z.ZodString, z.ZodString>;
        totalLiquidityInDollars: z.ZodString;
        totalRewardRatePerWeek: z.ZodString;
        totalStakedAmountInDollars: z.ZodString;
        totalSupply: z.ZodString;
        totalVoted: z.ZodString;
        weight: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        price: string;
        totalRewardRatePerWeek: string;
        currentAPR: string;
        reserves: Record<string, string>;
        totalLiquidityInDollars: string;
        totalStakedAmountInDollars: string;
        totalSupply: string;
        totalVoted: string;
        weight: string;
        isUser?: boolean | undefined;
    }, {
        price: string;
        totalRewardRatePerWeek: string;
        currentAPR: string;
        reserves: Record<string, string>;
        totalLiquidityInDollars: string;
        totalStakedAmountInDollars: string;
        totalSupply: string;
        totalVoted: string;
        weight: string;
        isUser?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    pools: Record<string, {
        price: string;
        totalRewardRatePerWeek: string;
        currentAPR: string;
        reserves: Record<string, string>;
        totalLiquidityInDollars: string;
        totalStakedAmountInDollars: string;
        totalSupply: string;
        totalVoted: string;
        weight: string;
        isUser?: boolean | undefined;
    }>;
    governance: {
        apr: string;
        rewardRate: string;
        totalBalance: string;
    };
    totalRewardRatePerWeek: string;
}, {
    pools: Record<string, {
        price: string;
        totalRewardRatePerWeek: string;
        currentAPR: string;
        reserves: Record<string, string>;
        totalLiquidityInDollars: string;
        totalStakedAmountInDollars: string;
        totalSupply: string;
        totalVoted: string;
        weight: string;
        isUser?: boolean | undefined;
    }>;
    governance: {
        apr: string;
        rewardRate: string;
        totalBalance: string;
    };
    totalRewardRatePerWeek: string;
}>;

declare const _default$1: z.ZodObject<{
    amount: z.ZodNumber;
    count: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    amount: number;
    count: number;
}, {
    amount: number;
    count: number;
}>;

declare const poolsLpAndStakedSchema: z.ZodRecord<z.ZodString, z.ZodObject<{
    unstakedLPBalance: z.ZodString;
    stakedLPBalance: z.ZodString;
}, "strip", z.ZodTypeAny, {
    unstakedLPBalance: string;
    stakedLPBalance: string;
}, {
    unstakedLPBalance: string;
    stakedLPBalance: string;
}>>;

declare const userVotesSchema: z.ZodRecord<z.ZodString, z.ZodString>;

declare const userEarnedSchema: z.ZodRecord<z.ZodString, z.ZodString>;

declare const poolsV3InfoSchema: z.ZodObject<{
    OrionV3Factory: z.ZodString;
    OrionV3Pool: z.ZodString;
    OrionV3NFTManager: z.ZodString;
}, "strip", z.ZodTypeAny, {
    OrionV3Factory: string;
    OrionV3Pool: string;
    OrionV3NFTManager: string;
}, {
    OrionV3Factory: string;
    OrionV3Pool: string;
    OrionV3NFTManager: string;
}>;

declare const pmmSchema: z.ZodObject<{
    orionPMMRouterContractAddress: z.ZodString;
}, "strip", z.ZodTypeAny, {
    orionPMMRouterContractAddress: string;
}, {
    orionPMMRouterContractAddress: string;
}>;

declare const pricesWithQuoteAssetSchema: z.ZodObject<{
    quoteAsset: z.ZodString;
    quoteAssetAddress: z.ZodString;
    prices: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodString>, Partial<Record<string, string>>, Record<string, string>>;
}, "strip", z.ZodTypeAny, {
    quoteAsset: string;
    quoteAssetAddress: string;
    prices: Partial<Record<string, string>>;
}, {
    quoteAsset: string;
    quoteAssetAddress: string;
    prices: Record<string, string>;
}>;

declare const referralDataSchema: z.ZodObject<{
    referer: z.ZodNullable<z.ZodString>;
    isReferral: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    referer: string | null;
    isReferral: boolean;
}, {
    referer: string | null;
    isReferral: boolean;
}>;

declare const index$g_IDOSchema: typeof IDOSchema;
type index$g_PairStatusEnum = PairStatusEnum;
declare const index$g_PairStatusEnum: typeof PairStatusEnum;
declare const index$g_addPoolSchema: typeof addPoolSchema;
declare const index$g_adminPoolSchema: typeof adminPoolSchema;
type index$g_adminPoolType = adminPoolType;
declare const index$g_atomicHistorySchema: typeof atomicHistorySchema;
declare const index$g_checkRedeemOrderSchema: typeof checkRedeemOrderSchema;
declare const index$g_historySchema: typeof historySchema;
declare const index$g_infoSchema: typeof infoSchema;
declare const index$g_pairStatusSchema: typeof pairStatusSchema;
declare const index$g_pmmSchema: typeof pmmSchema;
declare const index$g_poolOnVerificationSchema: typeof poolOnVerificationSchema;
declare const index$g_poolsConfigSchema: typeof poolsConfigSchema;
declare const index$g_poolsInfoSchema: typeof poolsInfoSchema;
declare const index$g_poolsLpAndStakedSchema: typeof poolsLpAndStakedSchema;
declare const index$g_poolsV3InfoSchema: typeof poolsV3InfoSchema;
declare const index$g_pricesWithQuoteAssetSchema: typeof pricesWithQuoteAssetSchema;
declare const index$g_referralDataSchema: typeof referralDataSchema;
declare const index$g_userEarnedSchema: typeof userEarnedSchema;
declare const index$g_userVotesSchema: typeof userVotesSchema;
declare namespace index$g {
    export {
        index$g_IDOSchema as IDOSchema,
        index$g_PairStatusEnum as PairStatusEnum,
        index$g_addPoolSchema as addPoolSchema,
        index$g_adminPoolSchema as adminPoolSchema,
        index$g_adminPoolType as adminPoolType,
        _default$2 as adminPoolsListSchema,
        index$g_atomicHistorySchema as atomicHistorySchema,
        _default$1 as atomicSummarySchema,
        index$g_checkRedeemOrderSchema as checkRedeemOrderSchema,
        index$g_historySchema as historySchema,
        index$g_infoSchema as infoSchema,
        index$g_pairStatusSchema as pairStatusSchema,
        index$g_pmmSchema as pmmSchema,
        index$g_poolOnVerificationSchema as poolOnVerificationSchema,
        index$g_poolsConfigSchema as poolsConfigSchema,
        index$g_poolsInfoSchema as poolsInfoSchema,
        index$g_poolsLpAndStakedSchema as poolsLpAndStakedSchema,
        index$g_poolsV3InfoSchema as poolsV3InfoSchema,
        index$g_pricesWithQuoteAssetSchema as pricesWithQuoteAssetSchema,
        index$g_referralDataSchema as referralDataSchema,
        index$g_userEarnedSchema as userEarnedSchema,
        index$g_userVotesSchema as userVotesSchema,
    };
}

declare const CANCEL_ORDER_TYPES: {
    DeleteOrder: {
        name: string;
        type: string;
    }[];
};

declare const orderStatuses: readonly ["NEW", "ACCEPTED", "PARTIALLY_FILLED", "FILLED", "TX_PENDING", "CANCELED", "REJECTED", "FAILED", "SETTLED", "NOT_FOUND", "ROUTING"];

declare const ORDER_TYPES: {
    Order: {
        name: string;
        type: string;
    }[];
};

declare const _default: readonly ["ASCENDEX", "OKX", "BINANCE", "KUCOIN", "ORION", "INTERNAL_ORDER_BOOK", "SPOOKYSWAP", "PANCAKESWAP", "UNISWAP", "QUICKSWAP", "ORION_POOL", "INTERNAL_POOL_V2", "INTERNAL_POOL_V3", "INTERNAL_POOL_V3_0_01", "INTERNAL_POOL_V3_0_05", "INTERNAL_POOL_V3_0_3", "INTERNAL_POOL_V3_1_0", "CHERRYSWAP", "OKXSWAP", "CURVE", "CURVE_FACTORY", "THENA_ALGEBRA_V1"];

declare const mapping: Record<string, string>;

declare const developmentChains: SupportedChainId[];
declare const productionChains: SupportedChainId[];

declare const INTERNAL_PROTOCOL_PRECISION = 8;
declare const NATIVE_CURRENCY_PRECISION = 18;

declare const DEPOSIT_ETH_GAS_LIMIT = 70000;
declare const DEPOSIT_ERC20_GAS_LIMIT = 150000;
declare const WITHDRAW_GAS_LIMIT = 150000;
declare const APPROVE_ERC20_GAS_LIMIT = 80000;
declare const STAKE_ERC20_GAS_LIMIT = 150000;
declare const VOTE_ERC20_GAS_LIMIT = 150000;
declare const FILL_ORDERS_GAS_LIMIT = 220000;
declare const SWAP_THROUGH_ORION_POOL_GAS_LIMIT = 600000;
declare const ADD_LIQUIDITY_GAS_LIMIT = 600000;
declare const FARMING_STAKE_GAS_LIMIT = 350000;
declare const FARMING_CLAIM_GAS_LIMIT = 350000;
declare const FARMING_EXIT_GAS_LIMIT = 500000;
declare const FARMING_WITHDRAW_GAS_LIMIT = 350000;
declare const GOVERNANCE_GET_REWARD_GAS_LIMIT = 250000;
declare const GOVERNANCE_STAKE_GAS_LIMIT = 300000;
declare const GOVERNANCE_UNSTAKE_GAS_LIMIT = 250000;
declare const GOVERNANCE_VOTE_GAS_LIMIT = 200000;
declare const MIGRATE_GAS_LIMIT = 800000;
declare const LOCKATOMIC_GAS_LIMIT = 200000;
declare const REDEEMATOMIC_GAS_LIMIT = 200000;
declare const LIQUIDITY_MIGRATE_GAS_LIMIT = 600000;
declare const DEFAULT_GAS_LIMIT = 700000;
declare const TOKEN_EXCEPTIONS: Record<string, Record<string, number>>;

declare const DAY = 86400;
declare const WEEK_DAYS = 7;
declare const YEAR: number;

declare const SERVICE_TOKEN = "ORN";

type IAdminAuthHeaders = {
    auth: string;
    [key: string]: string;
};
type IEditPool = {
    tokenAIcon?: string;
    tokenBIcon?: string;
    symbol?: string;
    status: PairStatusEnum;
    minQty?: number;
    tokenASymbol?: string;
    tokenBSymbol?: string;
    tokensReversed?: boolean;
};
type AtomicSwapHistoryBaseQuery = {
    limit?: number;
    sender?: string;
    receiver?: string;
    used?: 0 | 1;
    page?: number;
    sourceNetworkCode?: typeof _default$3[number];
} & Partial<Record<string, string | number>>;
type AtomicSwapHistorySourceQuery = AtomicSwapHistoryBaseQuery & {
    type?: 'source';
    expiredLock?: 0 | 1;
    state?: 'BEFORE-LOCK' | 'LOCKED' | 'CLAIMED' | 'REFUNDED';
};
type AtomicSwapHistoryTargetQuery = AtomicSwapHistoryBaseQuery & {
    type?: 'target';
    expiredRedeem?: 0 | 1;
    state?: 'REDEEMED' | 'BEFORE-REDEEM';
};
type PlatformFees = {
    assetIn: string;
    assetOut: string;
    walletAddress?: string | undefined;
    fromWidget?: string | undefined;
};
declare class BlockchainService {
    private readonly apiUrl;
    private readonly basicAuth?;
    get api(): string;
    constructor(apiUrl: string, basicAuth?: BasicAuthCredentials);
    get basicAuthHeaders(): {
        Authorization: string;
    } | {
        Authorization?: never;
    };
    get blockchainServiceWsUrl(): string;
    private readonly getSummaryRedeem;
    private readonly getSummaryClaim;
    private readonly getQueueLength;
    get internal(): {
        getSummaryRedeem: (brokerAddress: string, unshifted?: 0 | 1 | undefined, sourceNetworkCode?: "eth" | "bsc" | "opbnb" | "arb" | "ftm" | "polygon" | "okc" | "drip" | "inevm" | "linea" | "avax" | "base" | undefined) => Promise<neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: undefined;
            type: "fetchError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: undefined;
            type: "unknownFetchThrow";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "unknownGetTextError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "unknownGetTextUnknownError";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "serverError";
            url: string;
            message: string;
            text: string;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "jsonParseError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "jsonParseUnknownError";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientError";
            url: string;
            message: string;
            text: string;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientErrorWithResponsePayload";
            url: string;
            message: string;
            payload: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientErrorPayloadParseError";
            url: string;
            message: string;
            text: string;
            error: z.ZodError<unknown>;
        }> | neverthrow.Ok<{
            response: Response;
            data: {
                amount: number;
                count: number;
            };
        }, never> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "payloadParseError";
            url: string;
            message: string;
            error: z.ZodError<{
                amount: number;
                count: number;
            }>;
        }>>;
        getSummaryClaim: (brokerAddress: string) => Promise<neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: undefined;
            type: "fetchError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: undefined;
            type: "unknownFetchThrow";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "unknownGetTextError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "unknownGetTextUnknownError";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "serverError";
            url: string;
            message: string;
            text: string;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "jsonParseError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "jsonParseUnknownError";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientError";
            url: string;
            message: string;
            text: string;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientErrorWithResponsePayload";
            url: string;
            message: string;
            payload: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientErrorPayloadParseError";
            url: string;
            message: string;
            text: string;
            error: z.ZodError<unknown>;
        }> | neverthrow.Ok<{
            response: Response;
            data: {
                amount: number;
                count: number;
            };
        }, never> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "payloadParseError";
            url: string;
            message: string;
            error: z.ZodError<{
                amount: number;
                count: number;
            }>;
        }>>;
        getQueueLength: () => Promise<neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: undefined;
            type: "fetchError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: undefined;
            type: "unknownFetchThrow";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "unknownGetTextError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "unknownGetTextUnknownError";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "serverError";
            url: string;
            message: string;
            text: string;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "jsonParseError";
            url: string;
            message: string;
            error: Error;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "jsonParseUnknownError";
            url: string;
            message: string;
            error: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientError";
            url: string;
            message: string;
            text: string;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientErrorWithResponsePayload";
            url: string;
            message: string;
            payload: unknown;
        }> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "clientErrorPayloadParseError";
            url: string;
            message: string;
            text: string;
            error: z.ZodError<unknown>;
        }> | neverthrow.Ok<{
            response: Response;
            data: number;
        }, never> | neverthrow.Err<never, {
            requestOptions: {
                headers: HeadersInit;
                body?: BodyInit | null;
                cache?: RequestCache;
                credentials?: RequestCredentials;
                integrity?: string;
                keepalive?: boolean;
                method?: string;
                mode?: RequestMode;
                redirect?: RequestRedirect;
                referrer?: string;
                referrerPolicy?: ReferrerPolicy;
                signal?: AbortSignal | null;
                window?: null;
            };
            response: Response;
            type: "payloadParseError";
            url: string;
            message: string;
            error: z.ZodError<number>;
        }>>;
    };
    getAuthToken: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            token: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            token: string;
        }>;
    }>>;
    getCirculatingSupply: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: number;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<number>;
    }>>;
    getInfo: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            chainId: number;
            matcherAddress: string;
            chainName: string;
            exchangeContractAddress: string;
            swapExecutorContractAddress: string;
            oracleContractAddress: string;
            orderFeePercent: number;
            assetToAddress: Partial<Record<string, string>>;
            assetToDecimals: Partial<Record<string, number>>;
            cexTokens: string[];
            assetToIcons?: Partial<Record<string, string>> | undefined;
            internalFeeAssets?: {
                type: "percent" | "plain";
                value: number;
                asset: string;
            }[] | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            chainId: number;
            matcherAddress: string;
            chainName: string;
            exchangeContractAddress: string;
            swapExecutorContractAddress: string;
            oracleContractAddress: string;
            orderFeePercent: number;
            assetToAddress: Record<string, string>;
            assetToDecimals: Record<string, number>;
            cexTokens: string[];
            assetToIcons?: Record<string, string> | undefined;
            internalFeeAssets?: {
                type: "percent" | "plain";
                value: number;
                asset: string;
            }[] | undefined;
        }>;
    }>>;
    getPmmInfo: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            orionPMMRouterContractAddress: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            orionPMMRouterContractAddress: string;
        }>;
    }>>;
    getPoolsConfig: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            pools: Partial<Record<string, {
                lpTokenAddress: string;
                stakingRewardAddress: string;
                minQty?: number | undefined;
                reverted?: boolean | undefined;
                rewardToken?: string | null | undefined;
                state?: number | undefined;
                rewardTokenDecimals?: number | undefined;
                stakingRewardFinish?: number | undefined;
                vote_rewards_disabled?: boolean | undefined;
            }>>;
            factoryAddress: string;
            routerAddress: string;
            WETHAddress?: string | undefined;
            governanceAddress?: string | undefined;
            votingAddress?: string | undefined;
            factories?: Partial<Record<string, string>> | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            pools: Record<string, {
                lpTokenAddress: string;
                stakingRewardAddress: string;
                minQty?: number | undefined;
                reverted?: boolean | undefined;
                rewardToken?: string | null | undefined;
                state?: number | undefined;
                rewardTokenDecimals?: number | undefined;
                stakingRewardFinish?: number | undefined;
                vote_rewards_disabled?: boolean | undefined;
            }>;
            factoryAddress: string;
            routerAddress: string;
            WETHAddress?: string | undefined;
            governanceAddress?: string | undefined;
            votingAddress?: string | undefined;
            factories?: Record<string, string> | undefined;
        }>;
    }>>;
    getPoolsInfo: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            pools: Record<string, {
                price: string;
                totalRewardRatePerWeek: string;
                currentAPR: string;
                reserves: Record<string, string>;
                totalLiquidityInDollars: string;
                totalStakedAmountInDollars: string;
                totalSupply: string;
                totalVoted: string;
                weight: string;
                isUser?: boolean | undefined;
            }>;
            governance: {
                apr: string;
                rewardRate: string;
                totalBalance: string;
            };
            totalRewardRatePerWeek: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            pools: Record<string, {
                price: string;
                totalRewardRatePerWeek: string;
                currentAPR: string;
                reserves: Record<string, string>;
                totalLiquidityInDollars: string;
                totalStakedAmountInDollars: string;
                totalSupply: string;
                totalVoted: string;
                weight: string;
                isUser?: boolean | undefined;
            }>;
            governance: {
                apr: string;
                rewardRate: string;
                totalBalance: string;
            };
            totalRewardRatePerWeek: string;
        }>;
    }>>;
    getPoolsLpAndStaked: (address: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Record<string, {
            unstakedLPBalance: string;
            stakedLPBalance: string;
        }>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, {
            unstakedLPBalance: string;
            stakedLPBalance: string;
        }>>;
    }>>;
    getUserVotes: (address: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Record<string, string>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, string>>;
    }>>;
    getUserEarned: (address: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Record<string, string>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, string>>;
    }>>;
    getPoolsV3Info: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            OrionV3Factory: string;
            OrionV3Pool: string;
            OrionV3NFTManager: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            OrionV3Factory: string;
            OrionV3Pool: string;
            OrionV3NFTManager: string;
        }>;
    }>>;
    getHistory: (address: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            type: "deposit" | "withdrawal";
            date: number;
            token: string;
            amount: string;
            status: HistoryTransactionStatus;
            transactionHash: string;
            user: string;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            type: "deposit" | "withdrawal";
            amount: string;
            asset: string;
            createdAt: number;
            amountNumber: string;
            assetAddress: string;
            transactionHash: string;
            user: string;
            contractBalance?: string | null | undefined;
            walletBalance?: string | null | undefined;
        }[]>;
    }>>;
    getPricesWithQuoteAsset: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            quoteAsset: string;
            quoteAssetAddress: string;
            prices: Partial<Record<string, string>>;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            quoteAsset: string;
            quoteAssetAddress: string;
            prices: Record<string, string>;
        }>;
    }>>;
    /**
     * @deprecated In favor of getPlatformFees
     */
    getTokensFee: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, string>>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Partial<Record<string, string>>;
    }, never>>;
    getPlatformFees: ({ assetIn, assetOut, walletAddress, fromWidget }: PlatformFees) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, string>>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Partial<Record<string, string>>;
    }, never>>;
    getReferralData: (walletAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            referer: string | null;
            isReferral: boolean;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            referer: string | null;
            isReferral: boolean;
        }>;
    }>>;
    getGasPriceWei: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string>;
    }>>;
    checkFreeRedeemAvailable: (walletAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: boolean;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<boolean>;
    }>>;
    getRedeemOrderBySecretHash: (secretHash: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            secretHash: string;
            secret: string;
            redeemTxHash: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            secretHash: string;
            secret: string;
            redeemTxHash: string;
        }>;
    }>>;
    claimOrder: (secretHash: string, targetNetwork: (typeof _default$3)[number], redeemTxHash?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string>;
    }>>;
    redeemAtomicSwap: (redeemOrder: z.infer<typeof redeemOrderSchema>, secret: string, sourceNetwork: (typeof _default$3)[number]) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string>;
    }>>;
    redeem2AtomicSwaps: (redeemOrder1: z.infer<typeof redeemOrderSchema>, secret1: string, redeemOrder2: z.infer<typeof redeemOrderSchema>, secret2: string, sourceNetwork: (typeof _default$3)[number]) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string>;
    }>>;
    checkRedeem: (secretHash: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: "OK" | "FAIL" | null;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<"OK" | "FAIL" | null>;
    }>>;
    checkRedeem2Atomics: (firstSecretHash: string, secondSecretHash: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: "OK" | "FAIL" | null;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<"OK" | "FAIL" | null>;
    }>>;
    getBlockNumber: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: number;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<number>;
    }>>;
    getIDOInfo: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            amount: number | null;
            address: string;
            amountInWei: number | null;
            amountInUSDT: number | null;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            amount: number | null;
            address: string;
            amountInWei: number | null;
            amountInUSDT: number | null;
        }>;
    }>>;
    checkAuth: (headers: IAdminAuthHeaders) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            auth: boolean;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            auth: boolean;
        }>;
    }>>;
    getPool: (address: string, headers: IAdminAuthHeaders) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            symbol: string;
            status: PairStatusEnum;
            address: string;
            isUser: boolean;
            tokenA: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokenB: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokensReversed: boolean;
            updatedAt: number;
            createdAt: number;
            _id?: string | undefined;
            minQty?: number | undefined;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            symbol: string;
            status: PairStatusEnum;
            address: string;
            isUser: boolean;
            tokenA: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokenB: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokensReversed: boolean;
            updatedAt: number;
            createdAt: number;
            _id?: string | undefined;
            minQty?: number | undefined;
        }>;
    }>>;
    getPoolsList: (headers: IAdminAuthHeaders) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            symbol: string;
            status: PairStatusEnum;
            address: string;
            isUser: boolean;
            tokenA: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokenB: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokensReversed: boolean;
            updatedAt: number;
            createdAt: number;
            _id?: string | undefined;
            minQty?: number | undefined;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            symbol: string;
            status: PairStatusEnum;
            address: string;
            isUser: boolean;
            tokenA: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokenB: {
                symbol: string;
                address: string;
                icon?: string | undefined;
                decimals?: number | undefined;
                isUser?: boolean | undefined;
            };
            tokensReversed: boolean;
            updatedAt: number;
            createdAt: number;
            _id?: string | undefined;
            minQty?: number | undefined;
        }[]>;
    }>>;
    editPool: (address: string, data: IEditPool, headers: IAdminAuthHeaders) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: PairStatusEnum;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<PairStatusEnum>;
    }>>;
    addPool: (data: z.infer<typeof addPoolSchema>) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Ok<{
        response: Response;
        data: number;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<number>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<string>;
    }>>;
    checkPoolInformation: (poolAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: PairStatusEnum;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<PairStatusEnum>;
    }>>;
    getAtomicSwapAssets: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: string[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<string[]>;
    }>>;
    /**
     * Sender is user address in source BlockchainService instance \
     * Receiver is user address in target BlockchainService instance
     */
    getAtomicSwapHistory: (query: AtomicSwapHistorySourceQuery | AtomicSwapHistoryTargetQuery) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            data: ({
                type: "source";
                asset: string;
                secretHash: `0x${string}`;
                sender: string;
                used: boolean;
                _id: string;
                claimed: boolean;
                isAggApplied: boolean;
                __v: number;
                targetChainId: number;
                receiver?: string | undefined;
                secret?: string | undefined;
                amountToReceive?: number | undefined;
                amountToSpend?: number | undefined;
                timestamp?: {
                    lock?: number | undefined;
                    claim?: number | undefined;
                    refund?: number | undefined;
                } | undefined;
                expiration?: {
                    lock?: number | undefined;
                } | undefined;
                state?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
                transactions?: {
                    lock?: string | undefined;
                    claim?: string | undefined;
                    refund?: string | undefined;
                } | undefined;
            } | {
                type: "target";
                asset: string;
                secretHash: `0x${string}`;
                sender: string;
                used: boolean;
                _id: string;
                claimed: boolean;
                isAggApplied: boolean;
                __v: number;
                receiver?: string | undefined;
                secret?: string | undefined;
                timestamp?: {
                    redeem?: number | undefined;
                } | undefined;
                expiration?: {
                    redeem?: number | undefined;
                } | undefined;
                state?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
                transactions?: {
                    redeem?: string | undefined;
                } | undefined;
            })[];
            success: boolean;
            count: number;
            total: number;
            pagination: {};
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            data: unknown[];
            success: boolean;
            count: number;
            total: number;
            pagination: {};
        }>;
    }>>;
    getSourceAtomicSwapHistory: (query: AtomicSwapHistorySourceQuery) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            data: {
                type: "source";
                asset: string;
                secretHash: `0x${string}`;
                sender: string;
                used: boolean;
                _id: string;
                claimed: boolean;
                isAggApplied: boolean;
                __v: number;
                targetChainId: number;
                receiver?: string | undefined;
                secret?: string | undefined;
                amountToReceive?: number | undefined;
                amountToSpend?: number | undefined;
                timestamp?: {
                    lock?: number | undefined;
                    claim?: number | undefined;
                    refund?: number | undefined;
                } | undefined;
                expiration?: {
                    lock?: number | undefined;
                } | undefined;
                state?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
                transactions?: {
                    lock?: string | undefined;
                    claim?: string | undefined;
                    refund?: string | undefined;
                } | undefined;
            }[];
            success: boolean;
            count: number;
            total: number;
            pagination: {};
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            data: {
                type: "source";
                asset: string;
                secretHash: string;
                sender: string;
                used: boolean;
                _id: string;
                claimed: boolean;
                isAggApplied: boolean;
                __v: number;
                targetChainId: number;
                receiver?: string | undefined;
                secret?: string | undefined;
                amountToReceive?: number | undefined;
                amountToSpend?: number | undefined;
                timestamp?: {
                    lock?: number | undefined;
                    claim?: number | undefined;
                    refund?: number | undefined;
                } | undefined;
                expiration?: {
                    lock?: number | undefined;
                } | undefined;
                state?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
                transactions?: {
                    lock?: string | undefined;
                    claim?: string | undefined;
                    refund?: string | undefined;
                } | undefined;
            }[];
            success: boolean;
            count: number;
            total: number;
            pagination: {};
        }>;
    }>>;
    getTargetAtomicSwapHistory: (query: AtomicSwapHistoryTargetQuery) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            data: {
                type: "target";
                asset: string;
                secretHash: `0x${string}`;
                sender: string;
                used: boolean;
                _id: string;
                claimed: boolean;
                isAggApplied: boolean;
                __v: number;
                receiver?: string | undefined;
                secret?: string | undefined;
                timestamp?: {
                    redeem?: number | undefined;
                } | undefined;
                expiration?: {
                    redeem?: number | undefined;
                } | undefined;
                state?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
                transactions?: {
                    redeem?: string | undefined;
                } | undefined;
            }[];
            success: boolean;
            count: number;
            total: number;
            pagination: {};
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            data: {
                type: "target";
                asset: string;
                secretHash: string;
                sender: string;
                used: boolean;
                _id: string;
                claimed: boolean;
                isAggApplied: boolean;
                __v: number;
                receiver?: string | undefined;
                secret?: string | undefined;
                timestamp?: {
                    redeem?: number | undefined;
                } | undefined;
                expiration?: {
                    redeem?: number | undefined;
                } | undefined;
                state?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
                transactions?: {
                    redeem?: string | undefined;
                } | undefined;
            }[];
            success: boolean;
            count: number;
            total: number;
            pagination: {};
        }>;
    }>>;
    checkIfHashUsed: (secretHashes: string[]) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Partial<Record<string, boolean>>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, boolean>>;
    }>>;
    getGasLimits: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Record<string, number>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, number>>;
    }>>;
    getExchangeContractWalletBalance: (exchangeContractAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Record<string, string>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Record<string, string>>;
    }>>;
}

type index$f_BlockchainService = BlockchainService;
declare const index$f_BlockchainService: typeof BlockchainService;
type index$f_IEditPool = IEditPool;
declare namespace index$f {
    export {
        index$f_BlockchainService as BlockchainService,
        index$f_IEditPool as IEditPool,
        index$g as schemas,
    };
}

declare const subscriptions: {
    allTickers: {
        schema: z.ZodEffects<z.ZodArray<z.ZodUnknown, "many">, Partial<Record<string, {
            pairName: string;
            lastPrice: string;
            openPrice: string;
            highPrice: string;
            lowPrice: string;
            volume24h: string;
        }>>, unknown[]>;
        payload: false;
    };
    ticker: {
        schema: z.ZodEffects<z.ZodTuple<[z.ZodNumber, z.ZodEffects<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>, {
            pairName: string;
            lastPrice: string;
            openPrice: string;
            highPrice: string;
            lowPrice: string;
            volume24h: string;
        }, [string, string, string, string, string, string]>], null>, {
            pairName: string;
            lastPrice: string;
            openPrice: string;
            highPrice: string;
            lowPrice: string;
            volume24h: string;
        }, [number, [string, string, string, string, string, string]]>;
        payload: true;
    };
    lastPrice: {
        schema: z.ZodEffects<z.ZodTuple<[z.ZodNumber, z.ZodString, z.ZodNumber], null>, {
            pair: string;
            price: number;
        }, [number, string, number]>;
        payload: true;
    };
    candle: {
        schema: z.ZodEffects<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodNumber, z.ZodNumber, z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>, {
            interval: string;
            pair: string;
            timeStart: number;
            timeEnd: number;
            close: string;
            open: string;
            high: string;
            low: string;
            volume: string;
        }, [string, string, number, number, string, string, string, string, string]>;
        payload: true;
    };
    cexPrices: {
        schema: z.ZodEffects<z.ZodArray<z.ZodUnknown, "many">, Partial<Record<string, {
            pairName: string;
            lastPrice: number;
        }>>, unknown[]>;
        payload: false;
    };
};
type SubscriptionType = keyof typeof subscriptions;
type Subscription<T extends SubscriptionType, Schema = z.infer<typeof subscriptions[T]['schema']>> = typeof subscriptions[T] extends {
    payload: true;
} ? {
    callback: (data: Schema) => void;
    errorCallback?: (error: Error) => void;
    payload: string;
} : {
    callback: (data: Schema) => void;
    errorCallback?: (error: Error) => void;
};

declare const tickerInfoSchema: z.ZodEffects<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>, {
    pairName: string;
    lastPrice: string;
    openPrice: string;
    highPrice: string;
    lowPrice: string;
    volume24h: string;
}, [string, string, string, string, string, string]>;

declare const candleSchema: z.ZodEffects<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodNumber, z.ZodNumber, z.ZodString, z.ZodString, z.ZodString, z.ZodString, z.ZodString], null>, {
    interval: string;
    pair: string;
    timeStart: number;
    timeEnd: number;
    close: string;
    open: string;
    high: string;
    low: string;
    volume: string;
}, [string, string, number, number, string, string, string, string, string]>;

declare const priceSchema: z.ZodEffects<z.ZodTuple<[z.ZodNumber, z.ZodString, z.ZodNumber], null>, {
    pair: string;
    price: number;
}, [number, string, number]>;

declare const allTickersSchema$1: z.ZodEffects<z.ZodArray<z.ZodUnknown, "many">, Partial<Record<string, {
    pairName: string;
    lastPrice: string;
    openPrice: string;
    highPrice: string;
    lowPrice: string;
    volume24h: string;
}>>, unknown[]>;

declare const cexPricesSchema: z.ZodEffects<z.ZodArray<z.ZodUnknown, "many">, Partial<Record<string, {
    pairName: string;
    lastPrice: number;
}>>, unknown[]>;

declare const index$e_candleSchema: typeof candleSchema;
declare const index$e_cexPricesSchema: typeof cexPricesSchema;
declare const index$e_priceSchema: typeof priceSchema;
declare const index$e_tickerInfoSchema: typeof tickerInfoSchema;
declare namespace index$e {
    export {
        allTickersSchema$1 as allTickersSchema,
        index$e_candleSchema as candleSchema,
        index$e_cexPricesSchema as cexPricesSchema,
        index$e_priceSchema as priceSchema,
        index$e_tickerInfoSchema as tickerInfoSchema,
    };
}

declare class PriceFeedWS {
    private subscriptions;
    private readonly url;
    readonly basicAuth?: BasicAuthCredentials | undefined;
    constructor(url: string, basicAuth?: BasicAuthCredentials);
    get api(): string;
    subscribe<S extends SubscriptionType>(type: S, params: Subscription<S>, onOpen?: (event: WebSocket$1.Event) => void): {
        type: S;
        id: string;
        unsubscribe: () => void;
    };
    unsubscribe(subType: SubscriptionType, subId: string): void;
}

type index$d_PriceFeedWS = PriceFeedWS;
declare const index$d_PriceFeedWS: typeof PriceFeedWS;
declare namespace index$d {
    export {
        index$d_PriceFeedWS as PriceFeedWS,
        index$e as schemas,
    };
}

declare const candlesSchema: z.ZodObject<{
    candles: z.ZodArray<z.ZodObject<{
        close: z.ZodString;
        high: z.ZodString;
        low: z.ZodString;
        open: z.ZodString;
        time: z.ZodNumber;
        timeEnd: z.ZodNumber;
        timeStart: z.ZodNumber;
        volume: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        close: string;
        high: string;
        low: string;
        open: string;
        time: number;
        timeEnd: number;
        timeStart: number;
        volume: string;
    }, {
        close: string;
        high: string;
        low: string;
        open: string;
        time: number;
        timeEnd: number;
        timeStart: number;
        volume: string;
    }>, "many">;
    timeStart: z.ZodNumber;
    timeEnd: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    candles: {
        close: string;
        high: string;
        low: string;
        open: string;
        time: number;
        timeEnd: number;
        timeStart: number;
        volume: string;
    }[];
    timeEnd: number;
    timeStart: number;
}, {
    candles: {
        close: string;
        high: string;
        low: string;
        open: string;
        time: number;
        timeEnd: number;
        timeStart: number;
        volume: string;
    }[];
    timeEnd: number;
    timeStart: number;
}>;

declare const statisticsOverviewSchema: z.ZodObject<{
    time: z.ZodNumber;
    statisticsOverview: z.ZodObject<{
        volume24h: z.ZodNumber;
        volume7d: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        volume24h: number;
        volume7d: number;
    }, {
        volume24h: number;
        volume7d: number;
    }>;
}, "strip", z.ZodTypeAny, {
    time: number;
    statisticsOverview: {
        volume24h: number;
        volume7d: number;
    };
}, {
    time: number;
    statisticsOverview: {
        volume24h: number;
        volume7d: number;
    };
}>;
declare const topPairsStatisticsSchema: z.ZodObject<{
    time: z.ZodNumber;
    topPairs: z.ZodArray<z.ZodObject<{
        assetPair: z.ZodString;
        statisticsOverview: z.ZodObject<{
            volume24h: z.ZodNumber;
            volume7d: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            volume24h: number;
            volume7d: number;
        }, {
            volume24h: number;
            volume7d: number;
        }>;
    }, "strip", z.ZodTypeAny, {
        assetPair: string;
        statisticsOverview: {
            volume24h: number;
            volume7d: number;
        };
    }, {
        assetPair: string;
        statisticsOverview: {
            volume24h: number;
            volume7d: number;
        };
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    time: number;
    topPairs: {
        assetPair: string;
        statisticsOverview: {
            volume24h: number;
            volume7d: number;
        };
    }[];
}, {
    time: number;
    topPairs: {
        assetPair: string;
        statisticsOverview: {
            volume24h: number;
            volume7d: number;
        };
    }[];
}>;

declare const allTickersSchema: z.ZodArray<z.ZodObject<{
    pair: z.ZodString;
    volume24: z.ZodNumber;
    change24: z.ZodNumber;
    lastPrice: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    pair: string;
    volume24: number;
    change24: number;
    lastPrice: number;
}, {
    pair: string;
    volume24: number;
    change24: number;
    lastPrice: number;
}>, "many">;

declare const index$c_allTickersSchema: typeof allTickersSchema;
declare const index$c_candlesSchema: typeof candlesSchema;
declare const index$c_statisticsOverviewSchema: typeof statisticsOverviewSchema;
declare const index$c_topPairsStatisticsSchema: typeof topPairsStatisticsSchema;
declare namespace index$c {
    export {
        index$c_allTickersSchema as allTickersSchema,
        index$c_candlesSchema as candlesSchema,
        index$c_statisticsOverviewSchema as statisticsOverviewSchema,
        index$c_topPairsStatisticsSchema as topPairsStatisticsSchema,
    };
}

declare class PriceFeed {
    private readonly apiUrl;
    private readonly basicAuth?;
    readonly ws: PriceFeedWS;
    get api(): string;
    constructor(apiUrl: string, basicAuth?: BasicAuthCredentials);
    get basicAuthHeaders(): {
        Authorization: string;
    } | {
        Authorization?: never;
    };
    getCandles: (symbol: string, timeStart: number, timeEnd: number, interval: '5m' | '30m' | '1h' | '1d', exchange?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            candles: {
                close: string;
                high: string;
                low: string;
                open: string;
                time: number;
                timeEnd: number;
                timeStart: number;
                volume: string;
            }[];
            timeEnd: number;
            timeStart: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            candles: {
                close: string;
                high: string;
                low: string;
                open: string;
                time: number;
                timeEnd: number;
                timeStart: number;
                volume: string;
            }[];
            timeEnd: number;
            timeStart: number;
        }>;
    }>>;
    getStatisticsOverview: (exchange?: string | 'ALL') => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            time: number;
            statisticsOverview: {
                volume24h: number;
                volume7d: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            time: number;
            statisticsOverview: {
                volume24h: number;
                volume7d: number;
            };
        }>;
    }>>;
    getTopPairStatistics: (exchange?: string | 'ALL') => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            time: number;
            topPairs: {
                assetPair: string;
                statisticsOverview: {
                    volume24h: number;
                    volume7d: number;
                };
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            time: number;
            topPairs: {
                assetPair: string;
                statisticsOverview: {
                    volume24h: number;
                    volume7d: number;
                };
            }[];
        }>;
    }>>;
    getAllTickers: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            pair: string;
            volume24: number;
            change24: number;
            lastPrice: number;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            pair: string;
            volume24: number;
            change24: number;
            lastPrice: number;
        }[]>;
    }>>;
    get wsUrl(): string;
    get candlesUrl(): string;
    get statisticsUrl(): string;
    get tickersUrl(): string;
}

type index$b_PriceFeed = PriceFeed;
declare const index$b_PriceFeed: typeof PriceFeed;
declare namespace index$b {
    export {
        index$b_PriceFeed as PriceFeed,
        index$c as schemas,
        index$d as ws,
    };
}

type SwapLimitParams = {
    type: 'exactSpend' | 'exactReceive';
    assetIn: string;
    assetOut: string;
    price: BigNumber.Value;
    amount: BigNumber.Value;
    feeAsset: string;
    signer: ethers.Signer;
    unit: Unit;
    options?: {
        poolOnly?: boolean;
        instantSettlement?: boolean;
        logger?: (message: string) => void;
        autoApprove?: boolean;
        developer?: {
            route?: 'aggregator' | 'pool';
        };
    };
};
type AggregatorOrder$1 = {
    amountOut: number;
    through: 'aggregator';
    id: string;
    wait: () => Promise<z.infer<typeof orderSchema>>;
};
type PoolSwap$1 = {
    amountOut: number;
    through: 'pool';
    txHash: string;
    wait: (confirmations?: number | undefined) => Promise<ethers.TransactionReceipt | null>;
};
type Swap$1 = AggregatorOrder$1 | PoolSwap$1;

type SwapMarketParams = Omit<SwapLimitParams, 'price'> & {
    slippagePercent: BigNumber.Value;
};
type AggregatorOrder = {
    amountOut: number;
    through: 'aggregator';
    id: string;
    wait: () => Promise<z.infer<typeof orderSchema>>;
};
type PoolSwap = {
    amountOut: number;
    through: 'pool';
    txHash: string;
    wait: (confirmations?: number | undefined) => Promise<ethers.TransactionReceipt | null>;
};
type Swap = AggregatorOrder | PoolSwap;

type DepositParams = {
    asset: string;
    amount: BigNumber.Value;
    signer: ethers.Signer;
    unit: Unit;
};

type GetSwapInfoParams = {
    type: 'exactSpend' | 'exactReceive';
    assetIn: string;
    assetOut: string;
    amount: BigNumber.Value;
    feeAsset: string;
    blockchainService: BlockchainService;
    aggregator: Aggregator;
    options?: {
        instantSettlement?: boolean;
        poolOnly?: boolean;
    };
    walletAddress?: string;
};

type BaseGenerateSwapCalldataParams = {
    amount: BigNumberish;
    minReturnAmount: BigNumberish;
    initiatorAddress: string;
    receiverAddress: string;
    path: ArrayLike<SingleSwap>;
    matcher?: AddressLike;
    feeToken?: AddressLike;
    fee?: BigNumberish;
};
type GenerateSwapCalldataWithUnitParams = BaseGenerateSwapCalldataParams & {
    unit: Unit;
};
type GenerateSwapCalldataParams = BaseGenerateSwapCalldataParams & {
    exchangeContractAddress: AddressLike;
    wethAddress: AddressLike;
    curveRegistryAddress: AddressLike;
    swapExecutorContractAddress: AddressLike;
    provider: JsonRpcProvider;
};
declare function generateSwapCalldata({ amount, minReturnAmount, initiatorAddress, receiverAddress, path: arrayLikePath, matcher: matcherAddressLike, feeToken: feeTokenAddressLike, fee, exchangeContractAddress, wethAddress: wethAddressLike, curveRegistryAddress: curveRegistryAddressLike, swapExecutorContractAddress: swapExecutorContractAddressLike, provider, }: GenerateSwapCalldataParams): Promise<{
    calldata: string;
    swapDescription: LibValidator.SwapDescriptionStruct;
    value: bigint;
}>;

type WithdrawParams = {
    asset: string;
    amount: BigNumber.Value;
    signer: ethers.Signer;
    unit: Unit;
};

type PureDepositParams = Omit<DepositParams, 'unit'>;
type PureWithdrawParams = Omit<WithdrawParams, 'unit'>;
type PureGetSwapMarketInfoParams = Omit<GetSwapInfoParams, 'blockchainService' | 'aggregator'>;
type PureGenerateSwapCalldataParams = Omit<GenerateSwapCalldataWithUnitParams, 'unit'>;
type PureSwapLimitParams = Omit<SwapLimitParams, 'unit'>;
type PureSwapMarketParams = Omit<SwapMarketParams, 'unit'>;
declare class Exchange {
    private readonly unit;
    constructor(unit: Unit);
    getSwapInfo(params: PureGetSwapMarketInfoParams): Promise<{
        route: "pool";
        swapInfo: {
            type: "exactSpend";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: number | null;
            marketAmountIn: null;
            availableAmountIn: number;
            availableAmountOut: null;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        } | {
            type: "exactReceive";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: null;
            marketAmountIn: number | null;
            availableAmountIn: null;
            availableAmountOut: number;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        };
        fee: {
            assetName: string;
            assetAddress: string;
            networkFeeInFeeAsset: string;
            protocolFeeInFeeAsset: undefined;
        };
    } | {
        route: "aggregator";
        swapInfo: {
            type: "exactSpend";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: number | null;
            marketAmountIn: null;
            availableAmountIn: number;
            availableAmountOut: null;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        } | {
            type: "exactReceive";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: null;
            marketAmountIn: number | null;
            availableAmountIn: null;
            availableAmountOut: number;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        };
        fee: {
            assetName: string;
            assetAddress: string;
            networkFeeInFeeAsset: bignumber_js.BigNumber;
            protocolFeeInFeeAsset: bignumber_js.BigNumber;
        };
    } | {
        route: "aggregator";
        swapInfo: {
            type: "exactSpend";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: number | null;
            marketAmountIn: null;
            availableAmountIn: number;
            availableAmountOut: null;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        } | {
            type: "exactReceive";
            path: string[];
            assetIn: string;
            assetOut: string;
            id: string;
            amountIn: number;
            amountOut: number;
            executionInfo: string;
            orderInfo: {
                assetPair: string;
                side: "BUY" | "SELL";
                amount: number;
                safePrice: number;
            } | null;
            exchanges: string[];
            price: number | null;
            minAmountOut: number;
            minAmountIn: number;
            marketPrice: number | null;
            exchangeContractPath: {
                pool: string;
                assetIn: string;
                assetOut: string;
                factory: string;
            }[];
            marketAmountOut: null;
            marketAmountIn: number | null;
            availableAmountIn: null;
            availableAmountOut: number;
            alternatives: {
                path: string[];
                orderInfo: {
                    assetPair: string;
                    side: "BUY" | "SELL";
                    amount: number;
                    safePrice: number;
                } | null;
                exchanges: string[];
                marketPrice: number;
                marketAmountOut: number | null;
                marketAmountIn: number | null;
                availableAmountIn: number | null;
                availableAmountOut: number | null;
                isThroughPoolOrCurve: boolean;
            }[];
            assetNameMapping?: Record<string, string> | undefined;
            usd?: {
                aa?: number | undefined;
                aao?: number | undefined;
                mo?: number | undefined;
                mi?: number | undefined;
                d?: string | undefined;
            } | undefined;
            autoSlippage?: number | undefined;
        };
        fee: {
            assetName: string;
            assetAddress: string;
            networkFeeInFeeAsset: undefined;
            protocolFeeInFeeAsset: undefined;
        };
    }>;
    deposit(params: PureDepositParams): Promise<void>;
    withdraw(params: PureWithdrawParams): Promise<void>;
    generateSwapCalldata(params: PureGenerateSwapCalldataParams): Promise<{
        calldata: string;
        swapDescription: _orionprotocol_contracts_lib_ethers_v6_Exchange_js.LibValidator.SwapDescriptionStruct;
        value: bigint;
    }>;
    swapLimit(params: PureSwapLimitParams): Promise<Swap$1>;
    swapMarket(params: PureSwapMarketParams): Promise<Swap>;
}

declare const environmentResponseSchema: z.ZodObject<{
    result: z.ZodObject<{
        chainId: z.ZodNumber;
        nativeToken: z.ZodString;
        ORN: z.ZodEffects<z.ZodString, string, string>;
        WETH9: z.ZodEffects<z.ZodString, string, string>;
        OrionV3Factory: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        OrionV2Factory: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        OrionV3NFTManager: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        SwapRouterV3: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        OrionFarmV3: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        OrionFarmV2: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        OrionVoting: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        veORN: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
    }, "strip", z.ZodTypeAny, {
        chainId: number;
        ORN: string;
        nativeToken: string;
        WETH9: string;
        OrionV3Factory?: string | undefined;
        OrionV2Factory?: string | undefined;
        OrionV3NFTManager?: string | undefined;
        SwapRouterV3?: string | undefined;
        OrionFarmV3?: string | undefined;
        OrionFarmV2?: string | undefined;
        OrionVoting?: string | undefined;
        veORN?: string | undefined;
    }, {
        chainId: number;
        ORN: string;
        nativeToken: string;
        WETH9: string;
        OrionV3Factory?: string | undefined;
        OrionV2Factory?: string | undefined;
        OrionV3NFTManager?: string | undefined;
        SwapRouterV3?: string | undefined;
        OrionFarmV3?: string | undefined;
        OrionFarmV2?: string | undefined;
        OrionVoting?: string | undefined;
        veORN?: string | undefined;
    }>;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        chainId: number;
        ORN: string;
        nativeToken: string;
        WETH9: string;
        OrionV3Factory?: string | undefined;
        OrionV2Factory?: string | undefined;
        OrionV3NFTManager?: string | undefined;
        SwapRouterV3?: string | undefined;
        OrionFarmV3?: string | undefined;
        OrionFarmV2?: string | undefined;
        OrionVoting?: string | undefined;
        veORN?: string | undefined;
    };
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        chainId: number;
        ORN: string;
        nativeToken: string;
        WETH9: string;
        OrionV3Factory?: string | undefined;
        OrionV2Factory?: string | undefined;
        OrionV3NFTManager?: string | undefined;
        SwapRouterV3?: string | undefined;
        OrionFarmV3?: string | undefined;
        OrionFarmV2?: string | undefined;
        OrionVoting?: string | undefined;
        veORN?: string | undefined;
    };
}>;

declare const listNFTOrderResponseSchema: z.ZodObject<{
    result: z.ZodArray<z.ZodObject<{
        tokenId: z.ZodEffects<z.ZodString, string, string>;
        token0: z.ZodString;
        token1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        token0Decimals: z.ZodNumber;
        token1Decimals: z.ZodNumber;
        amount: z.ZodNumber;
        amount0: z.ZodNumber;
        amount1: z.ZodNumber;
        from: z.ZodNumber;
        to: z.ZodNumber;
        fee: z.ZodNumber;
        collectFee: z.ZodNumber;
        reward: z.ZodNumber;
        apr: z.ZodNumber;
        boost: z.ZodNumber;
        isStaked: z.ZodBoolean;
        poolFee: z.ZodNumber;
        poolAddress: z.ZodEffects<z.ZodString, string, string>;
        veOrnForMaxBoost: z.ZodNumber;
        veOrnMaxBoost: z.ZodNumber;
        veORNCurrent: z.ZodNumber;
        time: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        amount: number;
        to: number;
        from: number;
        fee: number;
        poolAddress: string;
        apr: number;
        time: number;
        tokenId: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        amount0: number;
        amount1: number;
        collectFee: number;
        reward: number;
        boost: number;
        isStaked: boolean;
        poolFee: number;
        veOrnForMaxBoost: number;
        veOrnMaxBoost: number;
        veORNCurrent: number;
    }, {
        amount: number;
        to: number;
        from: number;
        fee: number;
        poolAddress: string;
        apr: number;
        time: number;
        tokenId: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        amount0: number;
        amount1: number;
        collectFee: number;
        reward: number;
        boost: number;
        isStaked: boolean;
        poolFee: number;
        veOrnForMaxBoost: number;
        veOrnMaxBoost: number;
        veORNCurrent: number;
    }>, "many">;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        amount: number;
        to: number;
        from: number;
        fee: number;
        poolAddress: string;
        apr: number;
        time: number;
        tokenId: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        amount0: number;
        amount1: number;
        collectFee: number;
        reward: number;
        boost: number;
        isStaked: boolean;
        poolFee: number;
        veOrnForMaxBoost: number;
        veOrnMaxBoost: number;
        veORNCurrent: number;
    }[];
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        amount: number;
        to: number;
        from: number;
        fee: number;
        poolAddress: string;
        apr: number;
        time: number;
        tokenId: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        amount0: number;
        amount1: number;
        collectFee: number;
        reward: number;
        boost: number;
        isStaked: boolean;
        poolFee: number;
        veOrnForMaxBoost: number;
        veOrnMaxBoost: number;
        veORNCurrent: number;
    }[];
}>;

declare const getPoolResponseSchema: z.ZodObject<{
    result: z.ZodObject<{
        token0: z.ZodString;
        token1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        totalLiquidity: z.ZodNumber;
        WETH9: z.ZodEffects<z.ZodString, string, string>;
        pools: z.ZodRecord<z.ZodNumber, z.ZodNullable<z.ZodObject<{
            poolAddress: z.ZodEffects<z.ZodString, string, string>;
            isInitialized: z.ZodBoolean;
            liquidity: z.ZodNumber;
            liquidityInUSD: z.ZodNumber;
            liquidityShare: z.ZodNumber;
            isFarming: z.ZodBoolean;
            rewardsTotal: z.ZodNumber;
            rewardsPerPeriod: z.ZodNumber;
            rewardsShare: z.ZodNumber;
            feePerPeriod: z.ZodNumber;
            feeTotal: z.ZodNumber;
            feeShare: z.ZodNumber;
            tickMultiplier: z.ZodNumber;
            MAX_TICK: z.ZodNumber;
            minAPR: z.ZodNumber;
            maxAPR: z.ZodNumber;
            avgAPR: z.ZodNumber;
            maxBoost: z.ZodNumber;
            feeRate: z.ZodArray<z.ZodNumber, "many">;
        }, "strip", z.ZodTypeAny, {
            poolAddress: string;
            isInitialized: boolean;
            liquidity: number;
            liquidityInUSD: number;
            liquidityShare: number;
            isFarming: boolean;
            rewardsTotal: number;
            rewardsPerPeriod: number;
            rewardsShare: number;
            feePerPeriod: number;
            feeTotal: number;
            feeShare: number;
            tickMultiplier: number;
            MAX_TICK: number;
            minAPR: number;
            maxAPR: number;
            avgAPR: number;
            maxBoost: number;
            feeRate: number[];
        }, {
            poolAddress: string;
            isInitialized: boolean;
            liquidity: number;
            liquidityInUSD: number;
            liquidityShare: number;
            isFarming: boolean;
            rewardsTotal: number;
            rewardsPerPeriod: number;
            rewardsShare: number;
            feePerPeriod: number;
            feeTotal: number;
            feeShare: number;
            tickMultiplier: number;
            MAX_TICK: number;
            minAPR: number;
            maxAPR: number;
            avgAPR: number;
            maxBoost: number;
            feeRate: number[];
        }>>>;
    }, "strip", z.ZodTypeAny, {
        pools: Record<number, {
            poolAddress: string;
            isInitialized: boolean;
            liquidity: number;
            liquidityInUSD: number;
            liquidityShare: number;
            isFarming: boolean;
            rewardsTotal: number;
            rewardsPerPeriod: number;
            rewardsShare: number;
            feePerPeriod: number;
            feeTotal: number;
            feeShare: number;
            tickMultiplier: number;
            MAX_TICK: number;
            minAPR: number;
            maxAPR: number;
            avgAPR: number;
            maxBoost: number;
            feeRate: number[];
        } | null>;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        totalLiquidity: number;
    }, {
        pools: Record<number, {
            poolAddress: string;
            isInitialized: boolean;
            liquidity: number;
            liquidityInUSD: number;
            liquidityShare: number;
            isFarming: boolean;
            rewardsTotal: number;
            rewardsPerPeriod: number;
            rewardsShare: number;
            feePerPeriod: number;
            feeTotal: number;
            feeShare: number;
            tickMultiplier: number;
            MAX_TICK: number;
            minAPR: number;
            maxAPR: number;
            avgAPR: number;
            maxBoost: number;
            feeRate: number[];
        } | null>;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        totalLiquidity: number;
    }>;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        pools: Record<number, {
            poolAddress: string;
            isInitialized: boolean;
            liquidity: number;
            liquidityInUSD: number;
            liquidityShare: number;
            isFarming: boolean;
            rewardsTotal: number;
            rewardsPerPeriod: number;
            rewardsShare: number;
            feePerPeriod: number;
            feeTotal: number;
            feeShare: number;
            tickMultiplier: number;
            MAX_TICK: number;
            minAPR: number;
            maxAPR: number;
            avgAPR: number;
            maxBoost: number;
            feeRate: number[];
        } | null>;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        totalLiquidity: number;
    };
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        pools: Record<number, {
            poolAddress: string;
            isInitialized: boolean;
            liquidity: number;
            liquidityInUSD: number;
            liquidityShare: number;
            isFarming: boolean;
            rewardsTotal: number;
            rewardsPerPeriod: number;
            rewardsShare: number;
            feePerPeriod: number;
            feeTotal: number;
            feeShare: number;
            tickMultiplier: number;
            MAX_TICK: number;
            minAPR: number;
            maxAPR: number;
            avgAPR: number;
            maxBoost: number;
            feeRate: number[];
        } | null>;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        totalLiquidity: number;
    };
}>;

declare const listPoolResponseSchema: z.ZodObject<{
    result: z.ZodArray<z.ZodUnion<[z.ZodObject<{
        type: z.ZodString;
        poolAddress: z.ZodEffects<z.ZodString, string, string>;
        isInitialized: z.ZodBoolean;
        liquidity: z.ZodNumber;
        liquidityInUSD: z.ZodNumber;
        liquidityShare: z.ZodNumber;
        isFarming: z.ZodBoolean;
        rewardsTotal: z.ZodNumber;
        rewardsPerPeriod: z.ZodNumber;
        rewardsShare: z.ZodNumber;
        feePerPeriod: z.ZodNumber;
        feeTotal: z.ZodNumber;
        feeShare: z.ZodNumber;
        tickMultiplier: z.ZodNumber;
        MAX_TICK: z.ZodNumber;
        minAPR: z.ZodNumber;
        maxAPR: z.ZodNumber;
        avgAPR: z.ZodNumber;
        maxBoost: z.ZodNumber;
        feeRate: z.ZodArray<z.ZodNumber, "many">;
        pair: z.ZodString;
        token0: z.ZodString;
        token1: z.ZodString;
        name: z.ZodString;
        name0: z.ZodString;
        name1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        token0Decimals: z.ZodNumber;
        token1Decimals: z.ZodNumber;
        WETH9: z.ZodEffects<z.ZodString, string, string>;
        farmAddress: z.ZodOptional<z.ZodString>;
        weight: z.ZodNumber;
        liquidity0: z.ZodNumber;
        liquidity1: z.ZodNumber;
        token0Price: z.ZodNumber;
        token1Price: z.ZodNumber;
        totalLPSupply: z.ZodNumber;
        totalLPStake: z.ZodNumber;
        totalLPStakeInUSD: z.ZodNumber;
        userLPStaked: z.ZodNumber;
        userLPStakedInUSD: z.ZodNumber;
        lpPriceInUSD: z.ZodNumber;
        lpPriceInORN: z.ZodNumber;
        userReward: z.ZodNumber;
        weeklyReward: z.ZodNumber;
        userAPR: z.ZodNumber;
        lockMaxMultiplier: z.ZodNumber;
        veornMaxMultiplier: z.ZodNumber;
        veornBoostScaleFactor: z.ZodNumber;
        lockTimeForMaxMultiplier: z.ZodNumber;
        userBoost: z.ZodNumber;
        userTimeDeposit: z.ZodNumber;
        userLockTimeStart: z.ZodNumber;
        userLockTimePeriod: z.ZodNumber;
        userVeORN: z.ZodNumber;
        userORN: z.ZodNumber;
        userRewardToPool: z.ZodNumber;
        boostTotalVeORN: z.ZodNumber;
        boostCurrentPoolReward: z.ZodNumber;
        boostTotalLiquidity: z.ZodNumber;
        boostCurrentLiquidity: z.ZodNumber;
        boostCurrentVeORN: z.ZodNumber;
        boostTotalReward: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    }, {
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"v3">;
        poolAddress: z.ZodEffects<z.ZodString, string, string>;
        isInitialized: z.ZodBoolean;
        liquidity: z.ZodNumber;
        liquidityInUSD: z.ZodNumber;
        liquidityShare: z.ZodNumber;
        isFarming: z.ZodBoolean;
        rewardsTotal: z.ZodNumber;
        rewardsPerPeriod: z.ZodNumber;
        rewardsShare: z.ZodNumber;
        feePerPeriod: z.ZodNumber;
        feeTotal: z.ZodNumber;
        feeShare: z.ZodNumber;
        tickMultiplier: z.ZodNumber;
        MAX_TICK: z.ZodNumber;
        minAPR: z.ZodNumber;
        maxAPR: z.ZodNumber;
        avgAPR: z.ZodNumber;
        maxBoost: z.ZodNumber;
        feeRate: z.ZodArray<z.ZodNumber, "many">;
        token0: z.ZodString;
        token1: z.ZodString;
        name: z.ZodString;
        name0: z.ZodString;
        name1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        token0Decimals: z.ZodNumber;
        token1Decimals: z.ZodNumber;
        WETH9: z.ZodEffects<z.ZodString, string, string>;
        poolFee: z.ZodNumber;
        weeklyReward: z.ZodNumber;
        weight: z.ZodNumber;
        totalLPStakeInUSD: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    }, {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    }>]>, "many">;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: ({
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    } | {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    })[];
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: ({
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    } | {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    })[];
}>;

declare const listPoolV2ResponseSchema: z.ZodObject<{
    result: z.ZodArray<z.ZodObject<{
        type: z.ZodString;
        poolAddress: z.ZodEffects<z.ZodString, string, string>;
        isInitialized: z.ZodBoolean;
        liquidity: z.ZodNumber;
        liquidityInUSD: z.ZodNumber;
        liquidityShare: z.ZodNumber;
        isFarming: z.ZodBoolean;
        rewardsTotal: z.ZodNumber;
        rewardsPerPeriod: z.ZodNumber;
        rewardsShare: z.ZodNumber;
        feePerPeriod: z.ZodNumber;
        feeTotal: z.ZodNumber;
        feeShare: z.ZodNumber;
        tickMultiplier: z.ZodNumber;
        MAX_TICK: z.ZodNumber;
        minAPR: z.ZodNumber;
        maxAPR: z.ZodNumber;
        avgAPR: z.ZodNumber;
        maxBoost: z.ZodNumber;
        feeRate: z.ZodArray<z.ZodNumber, "many">;
        pair: z.ZodString;
        token0: z.ZodString;
        token1: z.ZodString;
        name: z.ZodString;
        name0: z.ZodString;
        name1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        token0Decimals: z.ZodNumber;
        token1Decimals: z.ZodNumber;
        WETH9: z.ZodEffects<z.ZodString, string, string>;
        farmAddress: z.ZodOptional<z.ZodString>;
        weight: z.ZodNumber;
        liquidity0: z.ZodNumber;
        liquidity1: z.ZodNumber;
        token0Price: z.ZodNumber;
        token1Price: z.ZodNumber;
        totalLPSupply: z.ZodNumber;
        totalLPStake: z.ZodNumber;
        totalLPStakeInUSD: z.ZodNumber;
        userLPStaked: z.ZodNumber;
        userLPStakedInUSD: z.ZodNumber;
        lpPriceInUSD: z.ZodNumber;
        lpPriceInORN: z.ZodNumber;
        userReward: z.ZodNumber;
        weeklyReward: z.ZodNumber;
        userAPR: z.ZodNumber;
        lockMaxMultiplier: z.ZodNumber;
        veornMaxMultiplier: z.ZodNumber;
        veornBoostScaleFactor: z.ZodNumber;
        lockTimeForMaxMultiplier: z.ZodNumber;
        userBoost: z.ZodNumber;
        userTimeDeposit: z.ZodNumber;
        userLockTimeStart: z.ZodNumber;
        userLockTimePeriod: z.ZodNumber;
        userVeORN: z.ZodNumber;
        userORN: z.ZodNumber;
        userRewardToPool: z.ZodNumber;
        boostTotalVeORN: z.ZodNumber;
        boostCurrentPoolReward: z.ZodNumber;
        boostTotalLiquidity: z.ZodNumber;
        boostCurrentLiquidity: z.ZodNumber;
        boostCurrentVeORN: z.ZodNumber;
        boostTotalReward: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    }, {
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    }>, "many">;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    }[];
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        name: string;
        type: string;
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        farmAddress?: string | undefined;
    }[];
}>;

declare const PoolV2InfoResponseSchema: z.ZodObject<{
    result: z.ZodObject<{
        poolAddress: z.ZodEffects<z.ZodString, string, string>;
        isInitialized: z.ZodBoolean;
        liquidity: z.ZodNumber;
        liquidityInUSD: z.ZodNumber;
        liquidityShare: z.ZodNumber;
        isFarming: z.ZodBoolean;
        rewardsTotal: z.ZodNumber;
        rewardsPerPeriod: z.ZodNumber;
        rewardsShare: z.ZodNumber;
        feePerPeriod: z.ZodNumber;
        feeTotal: z.ZodNumber;
        feeShare: z.ZodNumber;
        tickMultiplier: z.ZodNumber;
        MAX_TICK: z.ZodNumber;
        minAPR: z.ZodNumber;
        maxAPR: z.ZodNumber;
        avgAPR: z.ZodNumber;
        maxBoost: z.ZodNumber;
        feeRate: z.ZodArray<z.ZodNumber, "many">;
        pair: z.ZodString;
        name: z.ZodString;
        token0: z.ZodString;
        token1: z.ZodString;
        name0: z.ZodString;
        name1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        token0Decimals: z.ZodNumber;
        token1Decimals: z.ZodNumber;
        WETH9: z.ZodString;
        farmAddress: z.ZodOptional<z.ZodString>;
        weight: z.ZodNumber;
        liquidity0: z.ZodNumber;
        liquidity1: z.ZodNumber;
        token0Price: z.ZodNumber;
        token1Price: z.ZodNumber;
        userLPBalance: z.ZodNumber;
        userLPBalanceStr: z.ZodString;
        totalLPSupply: z.ZodNumber;
        totalLPStake: z.ZodNumber;
        totalLPStakeInUSD: z.ZodNumber;
        userLPStaked: z.ZodNumber;
        userLPStakedInUSD: z.ZodNumber;
        lpPriceInUSD: z.ZodNumber;
        lpPriceInORN: z.ZodNumber;
        userReward: z.ZodNumber;
        userWeeklyReward: z.ZodNumber;
        userRewardToPool: z.ZodNumber;
        weeklyReward: z.ZodNumber;
        userAPR: z.ZodNumber;
        lockMaxMultiplier: z.ZodNumber;
        veornMaxMultiplier: z.ZodNumber;
        veornBoostScaleFactor: z.ZodNumber;
        lockTimeForMaxMultiplier: z.ZodNumber;
        userBoost: z.ZodNumber;
        userTimeDeposit: z.ZodNumber;
        userLockTimeStart: z.ZodNumber;
        userLockTimePeriod: z.ZodNumber;
        userVeORN: z.ZodNumber;
        userORN: z.ZodNumber;
        boostTotalVeORN: z.ZodNumber;
        boostCurrentPoolReward: z.ZodNumber;
        boostTotalLiquidity: z.ZodNumber;
        boostCurrentLiquidity: z.ZodNumber;
        boostCurrentVeORN: z.ZodNumber;
        boostTotalReward: z.ZodNumber;
        type: z.ZodLiteral<"v2">;
    }, "strip", z.ZodTypeAny, {
        name: string;
        type: "v2";
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        userLPBalance: number;
        userLPBalanceStr: string;
        userWeeklyReward: number;
        farmAddress?: string | undefined;
    }, {
        name: string;
        type: "v2";
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        userLPBalance: number;
        userLPBalanceStr: string;
        userWeeklyReward: number;
        farmAddress?: string | undefined;
    }>;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        name: string;
        type: "v2";
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        userLPBalance: number;
        userLPBalanceStr: string;
        userWeeklyReward: number;
        farmAddress?: string | undefined;
    };
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        name: string;
        type: "v2";
        pair: string;
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        liquidity0: number;
        liquidity1: number;
        token0Price: number;
        token1Price: number;
        totalLPSupply: number;
        totalLPStake: number;
        totalLPStakeInUSD: number;
        userLPStaked: number;
        userLPStakedInUSD: number;
        lpPriceInUSD: number;
        lpPriceInORN: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        lockMaxMultiplier: number;
        veornMaxMultiplier: number;
        veornBoostScaleFactor: number;
        lockTimeForMaxMultiplier: number;
        userBoost: number;
        userTimeDeposit: number;
        userLockTimeStart: number;
        userLockTimePeriod: number;
        userVeORN: number;
        userORN: number;
        userRewardToPool: number;
        boostTotalVeORN: number;
        boostCurrentPoolReward: number;
        boostTotalLiquidity: number;
        boostCurrentLiquidity: number;
        boostCurrentVeORN: number;
        boostTotalReward: number;
        userLPBalance: number;
        userLPBalanceStr: string;
        userWeeklyReward: number;
        farmAddress?: string | undefined;
    };
}>;

declare const listPoolV3ResponseSchema: z.ZodObject<{
    result: z.ZodArray<z.ZodObject<{
        type: z.ZodLiteral<"v3">;
        poolAddress: z.ZodEffects<z.ZodString, string, string>;
        isInitialized: z.ZodBoolean;
        liquidity: z.ZodNumber;
        liquidityInUSD: z.ZodNumber;
        liquidityShare: z.ZodNumber;
        isFarming: z.ZodBoolean;
        rewardsTotal: z.ZodNumber;
        rewardsPerPeriod: z.ZodNumber;
        rewardsShare: z.ZodNumber;
        feePerPeriod: z.ZodNumber;
        feeTotal: z.ZodNumber;
        feeShare: z.ZodNumber;
        tickMultiplier: z.ZodNumber;
        MAX_TICK: z.ZodNumber;
        minAPR: z.ZodNumber;
        maxAPR: z.ZodNumber;
        avgAPR: z.ZodNumber;
        maxBoost: z.ZodNumber;
        feeRate: z.ZodArray<z.ZodNumber, "many">;
        token0: z.ZodString;
        token1: z.ZodString;
        name: z.ZodString;
        name0: z.ZodString;
        name1: z.ZodString;
        token0Address: z.ZodEffects<z.ZodString, string, string>;
        token1Address: z.ZodEffects<z.ZodString, string, string>;
        token0Decimals: z.ZodNumber;
        token1Decimals: z.ZodNumber;
        WETH9: z.ZodEffects<z.ZodString, string, string>;
        poolFee: z.ZodNumber;
        weeklyReward: z.ZodNumber;
        weight: z.ZodNumber;
        totalLPStakeInUSD: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    }, {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    }>, "many">;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    }[];
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        name: string;
        type: "v3";
        poolAddress: string;
        weight: number;
        WETH9: string;
        token0: string;
        token1: string;
        token0Address: string;
        token1Address: string;
        token0Decimals: number;
        token1Decimals: number;
        poolFee: number;
        isInitialized: boolean;
        liquidity: number;
        liquidityInUSD: number;
        liquidityShare: number;
        isFarming: boolean;
        rewardsTotal: number;
        rewardsPerPeriod: number;
        rewardsShare: number;
        feePerPeriod: number;
        feeTotal: number;
        feeShare: number;
        tickMultiplier: number;
        MAX_TICK: number;
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        maxBoost: number;
        feeRate: number[];
        name0: string;
        name1: string;
        totalLPStakeInUSD: number;
        weeklyReward: number;
    }[];
}>;

declare const veORNInfoSchema: z.ZodObject<{
    result: z.ZodObject<{
        avgAPR: z.ZodNumber;
        minAPR: z.ZodNumber;
        maxAPR: z.ZodNumber;
        veTokenAddress: z.ZodEffects<z.ZodString, string, string>;
        totalORNLocked: z.ZodNumber;
        totalVeORN: z.ZodNumber;
        weeklyReward: z.ZodNumber;
        userAPR: z.ZodNumber;
        userVeORN: z.ZodNumber;
        userORNLocked: z.ZodNumber;
        userLockEndDate: z.ZodNumber;
        userReward: z.ZodNumber;
        userWeeklyReward: z.ZodNumber;
        userMinLockPeriod: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        userVeORN: number;
        userWeeklyReward: number;
        veTokenAddress: string;
        totalORNLocked: number;
        totalVeORN: number;
        userORNLocked: number;
        userLockEndDate: number;
        userMinLockPeriod: number;
    }, {
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        userVeORN: number;
        userWeeklyReward: number;
        veTokenAddress: string;
        totalORNLocked: number;
        totalVeORN: number;
        userORNLocked: number;
        userLockEndDate: number;
        userMinLockPeriod: number;
    }>;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        userVeORN: number;
        userWeeklyReward: number;
        veTokenAddress: string;
        totalORNLocked: number;
        totalVeORN: number;
        userORNLocked: number;
        userLockEndDate: number;
        userMinLockPeriod: number;
    };
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        minAPR: number;
        maxAPR: number;
        avgAPR: number;
        userReward: number;
        weeklyReward: number;
        userAPR: number;
        userVeORN: number;
        userWeeklyReward: number;
        veTokenAddress: string;
        totalORNLocked: number;
        totalVeORN: number;
        userORNLocked: number;
        userLockEndDate: number;
        userMinLockPeriod: number;
    };
}>;

declare const listAmountSchema: z.ZodObject<{
    result: z.ZodRecord<z.ZodString, z.ZodNumber>;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: Record<string, number>;
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: Record<string, number>;
}>;

declare const votingInfoSchema: z.ZodObject<{
    result: z.ZodObject<{
        absoluteVeTokenInVoting: z.ZodNumber;
        pools: z.ZodArray<z.ZodObject<{
            allVote: z.ZodNumber;
            name: z.ZodString;
            poolAddress: z.ZodString;
            type: z.ZodString;
            userVote: z.ZodNumber;
            token0: z.ZodString;
            token1: z.ZodString;
            name0: z.ZodString;
            name1: z.ZodString;
            poolFee: z.ZodNumber;
            userWeight: z.ZodNumber;
            weight: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            name: string;
            type: string;
            poolAddress: string;
            weight: number;
            token0: string;
            token1: string;
            poolFee: number;
            name0: string;
            name1: string;
            allVote: number;
            userVote: number;
            userWeight: number;
        }, {
            name: string;
            type: string;
            poolAddress: string;
            weight: number;
            token0: string;
            token1: string;
            poolFee: number;
            name0: string;
            name1: string;
            allVote: number;
            userVote: number;
            userWeight: number;
        }>, "many">;
        userVeTokenBalance: z.ZodNumber;
        userVeTokenInVoting: z.ZodNumber;
        veTokenAddress: z.ZodString;
        votingAddress: z.ZodString;
        weeklyReward: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        pools: {
            name: string;
            type: string;
            poolAddress: string;
            weight: number;
            token0: string;
            token1: string;
            poolFee: number;
            name0: string;
            name1: string;
            allVote: number;
            userVote: number;
            userWeight: number;
        }[];
        votingAddress: string;
        weeklyReward: number;
        veTokenAddress: string;
        absoluteVeTokenInVoting: number;
        userVeTokenBalance: number;
        userVeTokenInVoting: number;
    }, {
        pools: {
            name: string;
            type: string;
            poolAddress: string;
            weight: number;
            token0: string;
            token1: string;
            poolFee: number;
            name0: string;
            name1: string;
            allVote: number;
            userVote: number;
            userWeight: number;
        }[];
        votingAddress: string;
        weeklyReward: number;
        veTokenAddress: string;
        absoluteVeTokenInVoting: number;
        userVeTokenBalance: number;
        userVeTokenInVoting: number;
    }>;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        pools: {
            name: string;
            type: string;
            poolAddress: string;
            weight: number;
            token0: string;
            token1: string;
            poolFee: number;
            name0: string;
            name1: string;
            allVote: number;
            userVote: number;
            userWeight: number;
        }[];
        votingAddress: string;
        weeklyReward: number;
        veTokenAddress: string;
        absoluteVeTokenInVoting: number;
        userVeTokenBalance: number;
        userVeTokenInVoting: number;
    };
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: {
        pools: {
            name: string;
            type: string;
            poolAddress: string;
            weight: number;
            token0: string;
            token1: string;
            poolFee: number;
            name0: string;
            name1: string;
            allVote: number;
            userVote: number;
            userWeight: number;
        }[];
        votingAddress: string;
        weeklyReward: number;
        veTokenAddress: string;
        absoluteVeTokenInVoting: number;
        userVeTokenBalance: number;
        userVeTokenInVoting: number;
    };
}>;

declare const testIncrementorSchema: z.ZodObject<{
    result: z.ZodNumber;
    info: z.ZodObject<{
        blockNumber: z.ZodNumber;
        blockHash: z.ZodEffects<z.ZodString, string, string>;
        timeRequest: z.ZodNumber;
        timeAnswer: z.ZodNumber;
        changes: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }, {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    }>;
}, "strip", z.ZodTypeAny, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: number;
}, {
    info: {
        blockNumber: number;
        blockHash: string;
        timeRequest: number;
        timeAnswer: number;
        changes: number;
    };
    result: number;
}>;

declare const index$a_PoolV2InfoResponseSchema: typeof PoolV2InfoResponseSchema;
declare const index$a_environmentResponseSchema: typeof environmentResponseSchema;
declare const index$a_getPoolResponseSchema: typeof getPoolResponseSchema;
declare const index$a_listNFTOrderResponseSchema: typeof listNFTOrderResponseSchema;
declare const index$a_listPoolResponseSchema: typeof listPoolResponseSchema;
declare const index$a_listPoolV2ResponseSchema: typeof listPoolV2ResponseSchema;
declare const index$a_listPoolV3ResponseSchema: typeof listPoolV3ResponseSchema;
declare const index$a_testIncrementorSchema: typeof testIncrementorSchema;
declare namespace index$a {
    export {
        index$a_PoolV2InfoResponseSchema as PoolV2InfoResponseSchema,
        index$a_environmentResponseSchema as environmentResponseSchema,
        index$a_getPoolResponseSchema as getPoolResponseSchema,
        listAmountSchema as listAmountResponseSchema,
        index$a_listNFTOrderResponseSchema as listNFTOrderResponseSchema,
        index$a_listPoolResponseSchema as listPoolResponseSchema,
        index$a_listPoolV2ResponseSchema as listPoolV2ResponseSchema,
        index$a_listPoolV3ResponseSchema as listPoolV3ResponseSchema,
        index$a_testIncrementorSchema as testIncrementorSchema,
        veORNInfoSchema as veORNInfoResponseSchema,
        votingInfoSchema as votingInfoResponseSchema,
    };
}

type BasePayload = {
    chainId: number;
    jsonrpc: '1.0';
};
type GetEnvironmentPayload = BasePayload & {
    model: 'Environment';
    method: 'getEnvironment';
    params: [];
};
type ListNFTOrderPayload = BasePayload & {
    model: 'OrionV3NFTManager';
    method: 'listNFTOrder';
    params: [string];
};
type GetPoolInfoPayload = BasePayload & {
    model: 'OrionV3Factory' | 'OrionV2Factory';
    method: 'getPoolInfo';
    params: [string, string, string];
};
type ListPoolPayload = BasePayload & {
    model: 'OrionFarmV3';
    method: 'listPool';
    params: [string];
};
type VeORNInfoPayload = BasePayload & {
    model: 'veORN';
    method: 'info';
    params: [string];
};
type ListAmountPayload = BasePayload & {
    model: string;
    method: 'listAmount';
    params: [];
};
type GetAmountByORNPayload = BasePayload & {
    amountToken: number;
    timeLock: number;
};
type Payload = GetEnvironmentPayload | ListNFTOrderPayload | GetPoolInfoPayload | ListPoolPayload | VeORNInfoPayload | ListAmountPayload | GetAmountByORNPayload;
declare class IndexerService {
    private readonly apiUrl;
    private readonly chainId;
    get api(): string;
    constructor(apiUrl: string, chainId: number);
    readonly makeRPCPayload: (payload: Omit<Payload, 'chainId' | 'jsonrpc'>) => string;
    readonly veORNInfo: (address?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                userVeORN: number;
                userWeeklyReward: number;
                veTokenAddress: string;
                totalORNLocked: number;
                totalVeORN: number;
                userORNLocked: number;
                userLockEndDate: number;
                userMinLockPeriod: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                userVeORN: number;
                userWeeklyReward: number;
                veTokenAddress: string;
                totalORNLocked: number;
                totalVeORN: number;
                userORNLocked: number;
                userLockEndDate: number;
                userMinLockPeriod: number;
            };
        }>;
    }>>;
    /**
     * @param {number} amount - amount
     * @param {number} [timestamp = Date.now()] - timestamp, defaults to current time
     */
    readonly getAmountAt: (amount: number, timestamp?: number) => BigNumber;
    /**
     * @deprecated since version 69 in favor of getAmountAt
     */
    readonly getAmountAtCurrent: (amount: number) => BigNumber;
    readonly getAmountByORN: (amountToken: string, lockingDays: number) => BigNumber;
    readonly getVotingInfo: (userAddress?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                pools: {
                    name: string;
                    type: string;
                    poolAddress: string;
                    weight: number;
                    token0: string;
                    token1: string;
                    poolFee: number;
                    name0: string;
                    name1: string;
                    allVote: number;
                    userVote: number;
                    userWeight: number;
                }[];
                votingAddress: string;
                weeklyReward: number;
                veTokenAddress: string;
                absoluteVeTokenInVoting: number;
                userVeTokenBalance: number;
                userVeTokenInVoting: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                pools: {
                    name: string;
                    type: string;
                    poolAddress: string;
                    weight: number;
                    token0: string;
                    token1: string;
                    poolFee: number;
                    name0: string;
                    name1: string;
                    allVote: number;
                    userVote: number;
                    userWeight: number;
                }[];
                votingAddress: string;
                weeklyReward: number;
                veTokenAddress: string;
                absoluteVeTokenInVoting: number;
                userVeTokenBalance: number;
                userVeTokenInVoting: number;
            };
        }>;
    }>>;
    readonly getEnvironment: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                chainId: number;
                ORN: string;
                nativeToken: string;
                WETH9: string;
                OrionV3Factory?: string | undefined;
                OrionV2Factory?: string | undefined;
                OrionV3NFTManager?: string | undefined;
                SwapRouterV3?: string | undefined;
                OrionFarmV3?: string | undefined;
                OrionFarmV2?: string | undefined;
                OrionVoting?: string | undefined;
                veORN?: string | undefined;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                chainId: number;
                ORN: string;
                nativeToken: string;
                WETH9: string;
                OrionV3Factory?: string | undefined;
                OrionV2Factory?: string | undefined;
                OrionV3NFTManager?: string | undefined;
                SwapRouterV3?: string | undefined;
                OrionFarmV3?: string | undefined;
                OrionFarmV2?: string | undefined;
                OrionVoting?: string | undefined;
                veORN?: string | undefined;
            };
        }>;
    }>>;
    readonly listNFTOrder: (address: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                amount: number;
                to: number;
                from: number;
                fee: number;
                poolAddress: string;
                apr: number;
                time: number;
                tokenId: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                amount0: number;
                amount1: number;
                collectFee: number;
                reward: number;
                boost: number;
                isStaked: boolean;
                poolFee: number;
                veOrnForMaxBoost: number;
                veOrnMaxBoost: number;
                veORNCurrent: number;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                amount: number;
                to: number;
                from: number;
                fee: number;
                poolAddress: string;
                apr: number;
                time: number;
                tokenId: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                amount0: number;
                amount1: number;
                collectFee: number;
                reward: number;
                boost: number;
                isStaked: boolean;
                poolFee: number;
                veOrnForMaxBoost: number;
                veOrnMaxBoost: number;
                veORNCurrent: number;
            }[];
        }>;
    }>>;
    readonly getListPool: (userAddress?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: ({
                name: string;
                type: string;
                pair: string;
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                liquidity0: number;
                liquidity1: number;
                token0Price: number;
                token1Price: number;
                totalLPSupply: number;
                totalLPStake: number;
                totalLPStakeInUSD: number;
                userLPStaked: number;
                userLPStakedInUSD: number;
                lpPriceInUSD: number;
                lpPriceInORN: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                lockMaxMultiplier: number;
                veornMaxMultiplier: number;
                veornBoostScaleFactor: number;
                lockTimeForMaxMultiplier: number;
                userBoost: number;
                userTimeDeposit: number;
                userLockTimeStart: number;
                userLockTimePeriod: number;
                userVeORN: number;
                userORN: number;
                userRewardToPool: number;
                boostTotalVeORN: number;
                boostCurrentPoolReward: number;
                boostTotalLiquidity: number;
                boostCurrentLiquidity: number;
                boostCurrentVeORN: number;
                boostTotalReward: number;
                farmAddress?: string | undefined;
            } | {
                name: string;
                type: "v3";
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                poolFee: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                totalLPStakeInUSD: number;
                weeklyReward: number;
            })[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: ({
                name: string;
                type: string;
                pair: string;
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                liquidity0: number;
                liquidity1: number;
                token0Price: number;
                token1Price: number;
                totalLPSupply: number;
                totalLPStake: number;
                totalLPStakeInUSD: number;
                userLPStaked: number;
                userLPStakedInUSD: number;
                lpPriceInUSD: number;
                lpPriceInORN: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                lockMaxMultiplier: number;
                veornMaxMultiplier: number;
                veornBoostScaleFactor: number;
                lockTimeForMaxMultiplier: number;
                userBoost: number;
                userTimeDeposit: number;
                userLockTimeStart: number;
                userLockTimePeriod: number;
                userVeORN: number;
                userORN: number;
                userRewardToPool: number;
                boostTotalVeORN: number;
                boostCurrentPoolReward: number;
                boostTotalLiquidity: number;
                boostCurrentLiquidity: number;
                boostCurrentVeORN: number;
                boostTotalReward: number;
                farmAddress?: string | undefined;
            } | {
                name: string;
                type: "v3";
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                poolFee: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                totalLPStakeInUSD: number;
                weeklyReward: number;
            })[];
        }>;
    }>>;
    readonly getPoolInfo: (token0: string, token1: string, poolAddress?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                pools: Record<number, {
                    poolAddress: string;
                    isInitialized: boolean;
                    liquidity: number;
                    liquidityInUSD: number;
                    liquidityShare: number;
                    isFarming: boolean;
                    rewardsTotal: number;
                    rewardsPerPeriod: number;
                    rewardsShare: number;
                    feePerPeriod: number;
                    feeTotal: number;
                    feeShare: number;
                    tickMultiplier: number;
                    MAX_TICK: number;
                    minAPR: number;
                    maxAPR: number;
                    avgAPR: number;
                    maxBoost: number;
                    feeRate: number[];
                } | null>;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                totalLiquidity: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                pools: Record<number, {
                    poolAddress: string;
                    isInitialized: boolean;
                    liquidity: number;
                    liquidityInUSD: number;
                    liquidityShare: number;
                    isFarming: boolean;
                    rewardsTotal: number;
                    rewardsPerPeriod: number;
                    rewardsShare: number;
                    feePerPeriod: number;
                    feeTotal: number;
                    feeShare: number;
                    tickMultiplier: number;
                    MAX_TICK: number;
                    minAPR: number;
                    maxAPR: number;
                    avgAPR: number;
                    maxBoost: number;
                    feeRate: number[];
                } | null>;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                totalLiquidity: number;
            };
        }>;
    }>>;
    readonly listPoolV2: (address?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                name: string;
                type: string;
                pair: string;
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                liquidity0: number;
                liquidity1: number;
                token0Price: number;
                token1Price: number;
                totalLPSupply: number;
                totalLPStake: number;
                totalLPStakeInUSD: number;
                userLPStaked: number;
                userLPStakedInUSD: number;
                lpPriceInUSD: number;
                lpPriceInORN: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                lockMaxMultiplier: number;
                veornMaxMultiplier: number;
                veornBoostScaleFactor: number;
                lockTimeForMaxMultiplier: number;
                userBoost: number;
                userTimeDeposit: number;
                userLockTimeStart: number;
                userLockTimePeriod: number;
                userVeORN: number;
                userORN: number;
                userRewardToPool: number;
                boostTotalVeORN: number;
                boostCurrentPoolReward: number;
                boostTotalLiquidity: number;
                boostCurrentLiquidity: number;
                boostCurrentVeORN: number;
                boostTotalReward: number;
                farmAddress?: string | undefined;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                name: string;
                type: string;
                pair: string;
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                liquidity0: number;
                liquidity1: number;
                token0Price: number;
                token1Price: number;
                totalLPSupply: number;
                totalLPStake: number;
                totalLPStakeInUSD: number;
                userLPStaked: number;
                userLPStakedInUSD: number;
                lpPriceInUSD: number;
                lpPriceInORN: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                lockMaxMultiplier: number;
                veornMaxMultiplier: number;
                veornBoostScaleFactor: number;
                lockTimeForMaxMultiplier: number;
                userBoost: number;
                userTimeDeposit: number;
                userLockTimeStart: number;
                userLockTimePeriod: number;
                userVeORN: number;
                userORN: number;
                userRewardToPool: number;
                boostTotalVeORN: number;
                boostCurrentPoolReward: number;
                boostTotalLiquidity: number;
                boostCurrentLiquidity: number;
                boostCurrentVeORN: number;
                boostTotalReward: number;
                farmAddress?: string | undefined;
            }[];
        }>;
    }>>;
    readonly poolV2Info: (token0: string, token1: string, address: string | undefined) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                name: string;
                type: "v2";
                pair: string;
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                liquidity0: number;
                liquidity1: number;
                token0Price: number;
                token1Price: number;
                totalLPSupply: number;
                totalLPStake: number;
                totalLPStakeInUSD: number;
                userLPStaked: number;
                userLPStakedInUSD: number;
                lpPriceInUSD: number;
                lpPriceInORN: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                lockMaxMultiplier: number;
                veornMaxMultiplier: number;
                veornBoostScaleFactor: number;
                lockTimeForMaxMultiplier: number;
                userBoost: number;
                userTimeDeposit: number;
                userLockTimeStart: number;
                userLockTimePeriod: number;
                userVeORN: number;
                userORN: number;
                userRewardToPool: number;
                boostTotalVeORN: number;
                boostCurrentPoolReward: number;
                boostTotalLiquidity: number;
                boostCurrentLiquidity: number;
                boostCurrentVeORN: number;
                boostTotalReward: number;
                userLPBalance: number;
                userLPBalanceStr: string;
                userWeeklyReward: number;
                farmAddress?: string | undefined;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                name: string;
                type: "v2";
                pair: string;
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                liquidity0: number;
                liquidity1: number;
                token0Price: number;
                token1Price: number;
                totalLPSupply: number;
                totalLPStake: number;
                totalLPStakeInUSD: number;
                userLPStaked: number;
                userLPStakedInUSD: number;
                lpPriceInUSD: number;
                lpPriceInORN: number;
                userReward: number;
                weeklyReward: number;
                userAPR: number;
                lockMaxMultiplier: number;
                veornMaxMultiplier: number;
                veornBoostScaleFactor: number;
                lockTimeForMaxMultiplier: number;
                userBoost: number;
                userTimeDeposit: number;
                userLockTimeStart: number;
                userLockTimePeriod: number;
                userVeORN: number;
                userORN: number;
                userRewardToPool: number;
                boostTotalVeORN: number;
                boostCurrentPoolReward: number;
                boostTotalLiquidity: number;
                boostCurrentLiquidity: number;
                boostCurrentVeORN: number;
                boostTotalReward: number;
                userLPBalance: number;
                userLPBalanceStr: string;
                userWeeklyReward: number;
                farmAddress?: string | undefined;
            };
        }>;
    }>>;
    readonly listPoolV3: (address?: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                name: string;
                type: "v3";
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                poolFee: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                totalLPStakeInUSD: number;
                weeklyReward: number;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: {
                name: string;
                type: "v3";
                poolAddress: string;
                weight: number;
                WETH9: string;
                token0: string;
                token1: string;
                token0Address: string;
                token1Address: string;
                token0Decimals: number;
                token1Decimals: number;
                poolFee: number;
                isInitialized: boolean;
                liquidity: number;
                liquidityInUSD: number;
                liquidityShare: number;
                isFarming: boolean;
                rewardsTotal: number;
                rewardsPerPeriod: number;
                rewardsShare: number;
                feePerPeriod: number;
                feeTotal: number;
                feeShare: number;
                tickMultiplier: number;
                MAX_TICK: number;
                minAPR: number;
                maxAPR: number;
                avgAPR: number;
                maxBoost: number;
                feeRate: number[];
                name0: string;
                name1: string;
                totalLPStakeInUSD: number;
                weeklyReward: number;
            }[];
        }>;
    }>>;
    readonly listAmount: (poolKey: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: Record<string, number>;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: Record<string, number>;
        }>;
    }>>;
    readonly testRetrieve: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            info: {
                blockNumber: number;
                blockHash: string;
                timeRequest: number;
                timeAnswer: number;
                changes: number;
            };
            result: number;
        }>;
    }>>;
    private readonly getK;
}

type index$9_IndexerService = IndexerService;
declare const index$9_IndexerService: typeof IndexerService;
declare namespace index$9 {
    export {
        index$9_IndexerService as IndexerService,
        index$a as schemas,
    };
}

declare class Pmm {
    private readonly unit;
    private readonly provider;
    private contractAddress;
    constructor(unit: Unit);
    private isInitialized;
    init(): Promise<void>;
    getContractAddress(): Promise<string>;
    setAllowance(token: string, amount: string, signer: Wallet): Promise<void>;
    fillRFQOrder(order: z.infer<typeof pmmOrderSchema>, signer: Wallet): Promise<any>;
}

type KnownConfig = {
    env: KnownEnv;
    chainId: SupportedChainId;
};
declare class Unit {
    readonly networkCode: (typeof _default$3)[number];
    readonly chainId: SupportedChainId;
    readonly provider: JsonRpcProvider;
    readonly blockchainService: BlockchainService;
    readonly indexer: IndexerService | undefined;
    readonly aggregator: Aggregator;
    readonly pmm: Pmm;
    readonly priceFeed: PriceFeed;
    readonly exchange: Exchange;
    readonly config: VerboseUnitConfig;
    readonly contracts: Record<string, string>;
    logger: ((message: string) => void) | undefined;
    constructor(config: KnownConfig | VerboseUnitConfig, logger?: ((message: string) => void) | undefined);
}

declare const getHistory: (units: Unit[], address: string, limit?: number) => Promise<Partial<Record<string, {
    creationDate: Date;
    sourceChainId: SupportedChainId;
    targetChainId: SupportedChainId;
    used: boolean;
    claimed: boolean;
    isAggApplied: boolean;
    asset: string;
    sender: string;
    secretHash: string;
    receiver?: string | undefined;
    secret?: string | undefined;
    timestamp: ({
        redeem?: number | undefined;
    } & {
        lock?: number | undefined;
        claim?: number | undefined;
        refund?: number | undefined;
    }) | undefined;
    expiration: ({
        redeem?: number | undefined;
    } & {
        lock?: number | undefined;
    }) | undefined;
    transactions: ({
        redeem?: string | undefined;
    } & {
        lock?: string | undefined;
        claim?: string | undefined;
        refund?: string | undefined;
    }) | undefined;
    lockOrder?: {
        amount: number;
        asset: string;
        expiration: number;
        secretHash: string;
        sender: string;
        used: boolean;
        sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
    } | undefined;
    redeemOrder?: {
        amount: number;
        asset: string;
        expiration: number;
        receiver: string;
        secretHash: string;
        sender: string;
        signature: string;
        claimReceiver: string;
    } | undefined;
    amountToReceive: number | undefined;
    amountToSpend: number | undefined;
    status: {
        source?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
        target?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
        aggregator?: "SETTLED" | "EXPIRED" | "ACTIVE" | undefined;
    };
}>>>;

type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type AssetPairUpdate = {
    minQty: number;
    pricePrecision: number;
};
type SubOrder = {
    pair: string;
    exchange: string;
    id: number;
    amount: number;
    settledAmount: number;
    price: number;
    status: typeof subOrderStatuses[number];
    side: 'BUY' | 'SELL';
    subOrdQty: number;
};
type Balance = {
    tradable: string;
    reserved: string;
    contract: string;
    wallet: string;
    allowance: string;
};
type PositionStatus = typeof positionStatuses[number];
type Order = {
    senderAddress: string;
    matcherAddress: string;
    baseAsset: string;
    quoteAsset: string;
    matcherFeeAsset: string;
    amount: number;
    price: number;
    matcherFee: number;
    nonce: number;
    expiration: number;
    buySide: 0 | 1;
};
type SignedOrder = {
    id: string;
    signature: string;
    needWithdraw?: boolean;
} & Order;
type CancelOrderRequest = {
    id: number | string;
    senderAddress: string;
};
type SignedCancelOrderRequest = {
    id: number | string;
    senderAddress: string;
    signature: string;
} & CancelOrderRequest;
type Pair = {
    name: string;
    baseCurrency: string;
    quoteCurrency: string;
    lastPrice: string;
    openPrice: string;
    change24h: string;
    high: string;
    low: string;
    vol24h: string;
};
declare enum SupportedChainId {
    MAINNET = "1",
    ROPSTEN = "3",
    GOERLI = "5",
    ARBITRUM = "42161",
    FANTOM_OPERA = "250",
    POLYGON = "137",
    OKC = "66",
    OPBNB = "204",
    INEVM = "2525",
    LINEA = "59144",
    AVAX = "43114",
    BASE = "8453",
    POLYGON_TESTNET = "80001",
    FANTOM_TESTNET = "4002",
    BSC = "56",
    BSC_TESTNET = "97",
    OKC_TESTNET = "65",
    DRIP_TESTNET = "56303",
    ARBITRUM_GOERLI = "421613"
}
declare const balanceTypes: readonly ["exchange", "wallet"];
type Source = typeof balanceTypes[number];
type Asset = {
    name: string;
    address: string;
};
type BalanceRequirement = {
    readonly reason: string;
    readonly asset: Asset;
    readonly amount: string;
    readonly sources: Source[];
    readonly spenderAddress?: string | undefined;
};
type AggregatedBalanceRequirement = {
    readonly asset: Asset;
    readonly sources: Source[];
    readonly spenderAddress?: string | undefined;
    items: Partial<Record<string, string>>;
};
type ApproveFix = {
    readonly type: 'byApprove';
    readonly targetAmount: BigNumber.Value;
    readonly spenderAddress: string;
};
type DepositFix = {
    readonly type: 'byDeposit';
    readonly amount: BigNumber.Value;
    readonly asset: string;
};
type Fix = ApproveFix | DepositFix;
type BalanceIssue = {
    readonly asset: Asset;
    readonly message: string;
    readonly sources: Source[];
    readonly fixes?: Fix[];
};
type OrderbookItem = {
    price: string;
    amount: string;
    exchanges: string[];
    vob: Array<{
        side: 'BUY' | 'SELL';
        pairName: string;
    }>;
};
type SwapInfoAlternative = {
    exchanges: string[];
    path: string[];
    marketAmountOut?: number | undefined;
    marketAmountIn?: number | undefined;
    marketPrice: number;
    availableAmountIn?: number | undefined;
    availableAmountOut?: number | undefined;
};
type Factory = typeof _default$4[number];
type SingleSwap = {
    pool: string;
    assetIn: string;
    assetOut: string;
    factory: Factory;
};
type SwapInfoBase = {
    swapRequestId: string;
    assetIn: string;
    assetOut: string;
    amountIn: number;
    amountOut: number;
    minAmountIn: number;
    minAmountOut: number;
    path: string[];
    exchangeContractPath: SingleSwap[];
    exchanges?: string[] | undefined;
    poolOptimal: boolean;
    price?: number | undefined;
    marketPrice?: number | undefined;
    orderInfo?: {
        pair: string;
        side: 'BUY' | 'SELL';
        amount: number;
        safePrice: number;
    } | undefined;
    alternatives: SwapInfoAlternative[];
    assetsNameMapping?: Partial<Record<string, string>> | undefined;
    usdInfo: {
        availableAmountIn: number | undefined;
        availableAmountOut: number | undefined;
        marketAmountOut: number | undefined;
        marketAmountIn: number | undefined;
        difference: string | undefined;
    } | undefined;
    autoSlippage: number | undefined;
};
type SwapInfoByAmountIn = SwapInfoBase & {
    kind: 'exactSpend';
    availableAmountIn?: number | undefined;
    marketAmountOut?: number | undefined;
};
type SwapInfoByAmountOut = SwapInfoBase & {
    kind: 'exactReceive';
    marketAmountIn?: number | undefined;
    availableAmountOut?: number | undefined;
};
type SwapInfo = SwapInfoByAmountIn | SwapInfoByAmountOut;
declare enum HistoryTransactionStatus {
    PENDING = "Pending",
    DONE = "Done",
    APPROVING = "Approving",
    CANCELLED = "Cancelled"
}
type BasicAuthCredentials = {
    username: string;
    password: string;
};
type VerboseUnitConfig = {
    chainId: SupportedChainId;
    nodeJsonRpc: string;
    services: {
        blockchainService: {
            http: string;
        };
        aggregator: {
            http: string;
            ws: string;
        };
        priceFeed: {
            api: string;
        };
        indexer?: {
            api: string;
        } | undefined;
    };
    basicAuth?: BasicAuthCredentials;
};
type KnownEnv = typeof knownEnvs[number];
type Json = string | number | boolean | null | Json[] | {
    [key: string]: Json;
};
type EnvConfig = {
    analyticsAPI: string | undefined;
    referralAPI: string;
    frontageAPI: string;
    networks: Partial<Record<SupportedChainId, VerboseUnitConfig>>;
};
type AggregatedAssets = Partial<Record<string, Partial<Record<SupportedChainId, {
    address: string;
}>>>>;
type RedeemOrder = {
    sender: string;
    receiver: string;
    asset: string;
    amount: number;
    expiration: number;
    secretHash: string;
    signature: string;
    claimReceiver: string;
};
interface AtomicSwapLocal {
    secret: string;
    secretHash: string;
    walletAddress: string;
    env?: string | undefined;
    sourceChainId?: SupportedChainId | undefined;
    targetChainId?: SupportedChainId | undefined;
    amount?: string | undefined;
    assetName?: string | undefined;
    liquidityMigrationTxHash?: string | undefined;
    lockTransactionHash?: string | undefined;
    refundTransactionHash?: string | undefined;
    creationDate?: number | undefined;
    lockExpiration?: number | undefined;
    placingOrderError?: string | undefined;
    redeemSettlement?: {
        type: 'own_tx';
    } | {
        type: 'orion_tx';
        requestedAt?: number;
        result?: {
            timestamp: number;
            value: 'success' | 'failed';
        };
    } | undefined;
}
declare enum TxStatus {
    QUEUED = "queued",
    SIGN_FAILED = "sign_failed",
    GAS_ESTIMATING = "gas_estimating",
    ESTIMATE_GAS_FAILED = "estimate_gas_failed",
    CANCELLED = "cancelled",
    PENDING = "pending",
    FAILED = "failed",
    SETTLED = "settled",
    SIGNING = "signing",
    UNKNOWN = "unknown"
}
declare enum TxType {
    SWAP_THROUGH_ORION_POOL = "SWAP_THROUGH_ORION_POOL",
    DEPOSIT = "DEPOSIT",
    WITHDRAW = "WITHDRAW",
    BRIDGE_LOCK = "BRIDGE_LOCK",
    BRIDGE_REDEEM = "BRIDGE_REDEEM",
    BRIDGE_REFUND = "BRIDGE_REFUND",
    LIQUIDITY_MIGRATION = "LIQUIDITY_MIGRATION",
    REDEEM_TWO_ATOMICS = "REDEEM_TWO_ATOMICS"
}
type TxDepositOrWithdrawPayload = {
    type: TxType.DEPOSIT | TxType.WITHDRAW;
    data: {
        asset: string;
        amount: string;
    };
};
type TxSwapThroughOrionPoolPayload = {
    type: TxType.SWAP_THROUGH_ORION_POOL;
    data: {
        side: 'buy' | 'sell';
        assetIn: string;
        assetOut: string;
        amount: string;
        price: string;
    };
};
type TxBridgePayload = {
    type: TxType.BRIDGE_LOCK | TxType.BRIDGE_REDEEM | TxType.BRIDGE_REFUND;
    data: {
        secretHash: string;
    };
};
type TxLiquidityMigrationPayload = {
    type: TxType.LIQUIDITY_MIGRATION;
    data: {
        source: SupportedChainId;
        target: SupportedChainId;
        pair: string;
        pairAddress: string;
        assetA: {
            amount: string;
            secretHash: string;
            secret: string;
        };
        assetB: {
            amount: string;
            secretHash: string;
            secret: string;
        };
        expiration: number;
        env?: string;
    };
};
type TxRedeemTwoAtomicsPayload = {
    type: TxType.REDEEM_TWO_ATOMICS;
    data: {
        secretHash1: string;
        secretHash2: string;
    };
};
type TransactionInfo = {
    id?: string;
    status?: TxStatus;
    hash?: string;
    payload?: TxDepositOrWithdrawPayload | TxSwapThroughOrionPoolPayload | TxBridgePayload | TxLiquidityMigrationPayload | TxRedeemTwoAtomicsPayload;
};
type BridgeHistory = Awaited<ReturnType<typeof getHistory>>;
type BridgeHistoryItem = NonNullable<BridgeHistory[string]>;
type AtomicSwap = Partial<Omit<BridgeHistoryItem, 'creationDate' | 'expiration' | 'secret'>> & Partial<Omit<AtomicSwapLocal, 'creationDate' | 'expiration' | 'secret'>> & {
    sourceChainId: SupportedChainId;
    targetChainId: SupportedChainId;
    lockExpiration: number;
    secretHash: string;
    walletAddress: string;
    secret?: string | undefined;
    creationDate?: number | undefined;
    redeemExpired?: boolean | undefined;
    lockTx?: TransactionInfo | undefined;
    redeemTx?: TransactionInfo | undefined;
    refundTx?: TransactionInfo | undefined;
    liquidityMigrationTx?: TransactionInfo | undefined;
};
type OrderSource = 'TERMINAL_MARKET' | 'TERMINAL_LIMIT' | 'SWAP_UI' | 'WIDGET';
type NetworkCode = typeof _default$3[number];
type TickersCategories = 'FAVORITES' | 'USD' | 'ORN' | 'NATIVE' | 'ALTS';
type TickersSortBy = 'PRICE' | 'CHANGE' | 'VOLUME';
type TickersSortType = 'ASCENDING' | 'DESCENDING';
type TickersBaseSearchParams = {
    currentNetwork?: NetworkCode;
    targetNetwork?: NetworkCode;
    sortBy?: TickersSortBy;
    sortType?: TickersSortType;
    offset?: number;
    limit?: number;
};

declare const pureEnvNetworksSchema: z.ZodObject<{
    api: z.ZodString;
    services: z.ZodObject<{
        blockchain: z.ZodObject<{
            http: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            http: string;
        }, {
            http: string;
        }>;
        aggregator: z.ZodObject<{
            http: z.ZodString;
            ws: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            http: string;
            ws: string;
        }, {
            http: string;
            ws: string;
        }>;
        priceFeed: z.ZodObject<{
            all: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            all: string;
        }, {
            all: string;
        }>;
        indexer: z.ZodOptional<z.ZodObject<{
            http: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            http: string;
        }, {
            http: string;
        }>>;
    }, "strip", z.ZodTypeAny, {
        blockchain: {
            http: string;
        };
        aggregator: {
            http: string;
            ws: string;
        };
        priceFeed: {
            all: string;
        };
        indexer?: {
            http: string;
        } | undefined;
    }, {
        blockchain: {
            http: string;
        };
        aggregator: {
            http: string;
            ws: string;
        };
        priceFeed: {
            all: string;
        };
        indexer?: {
            http: string;
        } | undefined;
    }>;
    rpc: z.ZodOptional<z.ZodString>;
    liquidityMigratorAddress: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    api: string;
    services: {
        blockchain: {
            http: string;
        };
        aggregator: {
            http: string;
            ws: string;
        };
        priceFeed: {
            all: string;
        };
        indexer?: {
            http: string;
        } | undefined;
    };
    rpc?: string | undefined;
    liquidityMigratorAddress?: string | undefined;
}, {
    api: string;
    services: {
        blockchain: {
            http: string;
        };
        aggregator: {
            http: string;
            ws: string;
        };
        priceFeed: {
            all: string;
        };
        indexer?: {
            http: string;
        } | undefined;
    };
    rpc?: string | undefined;
    liquidityMigratorAddress?: string | undefined;
}>;
declare const pureEnvPayloadSchema: z.ZodObject<{
    analyticsAPI: z.ZodOptional<z.ZodString>;
    referralAPI: z.ZodString;
    frontageAPI: z.ZodString;
    networks: z.ZodRecord<z.ZodNativeEnum<typeof SupportedChainId>, z.ZodObject<{
        api: z.ZodString;
        services: z.ZodObject<{
            blockchain: z.ZodObject<{
                http: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                http: string;
            }, {
                http: string;
            }>;
            aggregator: z.ZodObject<{
                http: z.ZodString;
                ws: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                http: string;
                ws: string;
            }, {
                http: string;
                ws: string;
            }>;
            priceFeed: z.ZodObject<{
                all: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                all: string;
            }, {
                all: string;
            }>;
            indexer: z.ZodOptional<z.ZodObject<{
                http: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                http: string;
            }, {
                http: string;
            }>>;
        }, "strip", z.ZodTypeAny, {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        }, {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        }>;
        rpc: z.ZodOptional<z.ZodString>;
        liquidityMigratorAddress: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    referralAPI: string;
    frontageAPI: string;
    networks: Partial<Record<SupportedChainId, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
    analyticsAPI?: string | undefined;
}, {
    referralAPI: string;
    frontageAPI: string;
    networks: Partial<Record<SupportedChainId, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
    analyticsAPI?: string | undefined;
}>;
declare const knownEnvs: readonly ["production", "staging", "testing"];
declare const pureEnvSchema: z.ZodRecord<z.ZodUnion<[z.ZodEnum<["production", "staging", "testing"]>, z.ZodString]>, z.ZodObject<{
    analyticsAPI: z.ZodOptional<z.ZodString>;
    referralAPI: z.ZodString;
    frontageAPI: z.ZodString;
    networks: z.ZodRecord<z.ZodNativeEnum<typeof SupportedChainId>, z.ZodObject<{
        api: z.ZodString;
        services: z.ZodObject<{
            blockchain: z.ZodObject<{
                http: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                http: string;
            }, {
                http: string;
            }>;
            aggregator: z.ZodObject<{
                http: z.ZodString;
                ws: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                http: string;
                ws: string;
            }, {
                http: string;
                ws: string;
            }>;
            priceFeed: z.ZodObject<{
                all: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                all: string;
            }, {
                all: string;
            }>;
            indexer: z.ZodOptional<z.ZodObject<{
                http: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                http: string;
            }, {
                http: string;
            }>>;
        }, "strip", z.ZodTypeAny, {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        }, {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        }>;
        rpc: z.ZodOptional<z.ZodString>;
        liquidityMigratorAddress: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    referralAPI: string;
    frontageAPI: string;
    networks: Partial<Record<SupportedChainId, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
    analyticsAPI?: string | undefined;
}, {
    referralAPI: string;
    frontageAPI: string;
    networks: Partial<Record<SupportedChainId, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
    analyticsAPI?: string | undefined;
}>>;

declare const pureChainInfoPayloadSchema: z.ZodObject<{
    chainId: z.ZodNativeEnum<typeof SupportedChainId>;
    label: z.ZodString;
    shortName: z.ZodString;
    code: z.ZodEnum<["ftm", "bsc", "eth", "polygon", "okc", "arb", "drip", "opbnb", "inevm", "linea", "avax", "base"]>;
    explorer: z.ZodString;
    rpc: z.ZodString;
    baseCurrencyName: z.ZodString;
    contracts: z.ZodRecord<z.ZodString, z.ZodString>;
}, "strip", z.ZodTypeAny, {
    chainId: SupportedChainId;
    code: "eth" | "bsc" | "opbnb" | "arb" | "ftm" | "polygon" | "okc" | "drip" | "inevm" | "linea" | "avax" | "base";
    rpc: string;
    label: string;
    shortName: string;
    explorer: string;
    baseCurrencyName: string;
    contracts: Record<string, string>;
}, {
    chainId: SupportedChainId;
    code: "eth" | "bsc" | "opbnb" | "arb" | "ftm" | "polygon" | "okc" | "drip" | "inevm" | "linea" | "avax" | "base";
    rpc: string;
    label: string;
    shortName: string;
    explorer: string;
    baseCurrencyName: string;
    contracts: Record<string, string>;
}>;
declare const pureChainInfoSchema: z.ZodRecord<z.ZodNativeEnum<typeof SupportedChainId>, z.ZodObject<{
    chainId: z.ZodNativeEnum<typeof SupportedChainId>;
    label: z.ZodString;
    shortName: z.ZodString;
    code: z.ZodEnum<["ftm", "bsc", "eth", "polygon", "okc", "arb", "drip", "opbnb", "inevm", "linea", "avax", "base"]>;
    explorer: z.ZodString;
    rpc: z.ZodString;
    baseCurrencyName: z.ZodString;
    contracts: z.ZodRecord<z.ZodString, z.ZodString>;
}, "strip", z.ZodTypeAny, {
    chainId: SupportedChainId;
    code: "eth" | "bsc" | "opbnb" | "arb" | "ftm" | "polygon" | "okc" | "drip" | "inevm" | "linea" | "avax" | "base";
    rpc: string;
    label: string;
    shortName: string;
    explorer: string;
    baseCurrencyName: string;
    contracts: Record<string, string>;
}, {
    chainId: SupportedChainId;
    code: "eth" | "bsc" | "opbnb" | "arb" | "ftm" | "polygon" | "okc" | "drip" | "inevm" | "linea" | "avax" | "base";
    rpc: string;
    label: string;
    shortName: string;
    explorer: string;
    baseCurrencyName: string;
    contracts: Record<string, string>;
}>>;

declare const index$8_eip712DomainSchema: typeof eip712DomainSchema;
declare const index$8_knownEnvs: typeof knownEnvs;
declare const index$8_pureChainInfoPayloadSchema: typeof pureChainInfoPayloadSchema;
declare const index$8_pureChainInfoSchema: typeof pureChainInfoSchema;
declare const index$8_pureEnvNetworksSchema: typeof pureEnvNetworksSchema;
declare const index$8_pureEnvPayloadSchema: typeof pureEnvPayloadSchema;
declare const index$8_pureEnvSchema: typeof pureEnvSchema;
declare namespace index$8 {
    export {
        index$8_eip712DomainSchema as eip712DomainSchema,
        index$8_knownEnvs as knownEnvs,
        index$8_pureChainInfoPayloadSchema as pureChainInfoPayloadSchema,
        index$8_pureChainInfoSchema as pureChainInfoSchema,
        index$8_pureEnvNetworksSchema as pureEnvNetworksSchema,
        index$8_pureEnvPayloadSchema as pureEnvPayloadSchema,
        index$8_pureEnvSchema as pureEnvSchema,
    };
}

declare const chains: Partial<Record<SupportedChainId, {
    chainId: SupportedChainId;
    code: "eth" | "bsc" | "opbnb" | "arb" | "ftm" | "polygon" | "okc" | "drip" | "inevm" | "linea" | "avax" | "base";
    rpc: string;
    label: string;
    shortName: string;
    explorer: string;
    baseCurrencyName: string;
    contracts: Record<string, string>;
}>>;
declare const envs: Record<string, {
    referralAPI: string;
    frontageAPI: string;
    networks: Partial<Record<SupportedChainId, {
        api: string;
        services: {
            blockchain: {
                http: string;
            };
            aggregator: {
                http: string;
                ws: string;
            };
            priceFeed: {
                all: string;
            };
            indexer?: {
                http: string;
            } | undefined;
        };
        rpc?: string | undefined;
        liquidityMigratorAddress?: string | undefined;
    }>>;
    analyticsAPI?: string | undefined;
}>;

declare const index$7_chains: typeof chains;
declare const index$7_envs: typeof envs;
declare namespace index$7 {
    export {
        index$7_chains as chains,
        index$7_envs as envs,
        index$8 as schemas,
    };
}

declare const linkSchema: z.ZodObject<{
    status: z.ZodString;
    referer: z.ZodString;
}, "strip", z.ZodTypeAny, {
    status: string;
    referer: string;
}, {
    status: string;
    referer: string;
}>;

declare const distinctAnalyticsSchema: z.ZodObject<{
    referer: z.ZodString;
    refs_info: z.ZodRecord<z.ZodString, z.ZodObject<{
        referral_address: z.ZodString;
        referral_earned_fees: z.ZodNumber;
        referer_earned_fees: z.ZodNumber;
        relative_ref_level: z.ZodNumber;
        reward_record_hash: z.ZodString;
        timestamp: z.ZodNumber;
        latest_timestamp: z.ZodNumber;
        latest_block: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        timestamp: number;
        referral_address: string;
        referral_earned_fees: number;
        referer_earned_fees: number;
        relative_ref_level: number;
        reward_record_hash: string;
        latest_timestamp: number;
        latest_block: number;
    }, {
        timestamp: number;
        referral_address: string;
        referral_earned_fees: number;
        referer_earned_fees: number;
        relative_ref_level: number;
        reward_record_hash: string;
        latest_timestamp: number;
        latest_block: number;
    }>>;
    total_sent_to_governance: z.ZodNumber;
    total_earned: z.ZodNumber;
    total_volume: z.ZodNumber;
    total_trades: z.ZodNumber;
    all_time_earnings_boost_only: z.ZodNumber;
    all_time_earnings_boost_only_usd: z.ZodNumber;
    all_time_earnings: z.ZodNumber;
    all_time_earnings_usd: z.ZodNumber;
    all_weekly_earnings: z.ZodNumber;
    all_weekly_earnings_usd: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    referer: string;
    refs_info: Record<string, {
        timestamp: number;
        referral_address: string;
        referral_earned_fees: number;
        referer_earned_fees: number;
        relative_ref_level: number;
        reward_record_hash: string;
        latest_timestamp: number;
        latest_block: number;
    }>;
    total_sent_to_governance: number;
    total_earned: number;
    total_volume: number;
    total_trades: number;
    all_time_earnings_boost_only: number;
    all_time_earnings_boost_only_usd: number;
    all_time_earnings: number;
    all_time_earnings_usd: number;
    all_weekly_earnings: number;
    all_weekly_earnings_usd: number;
}, {
    referer: string;
    refs_info: Record<string, {
        timestamp: number;
        referral_address: string;
        referral_earned_fees: number;
        referer_earned_fees: number;
        relative_ref_level: number;
        reward_record_hash: string;
        latest_timestamp: number;
        latest_block: number;
    }>;
    total_sent_to_governance: number;
    total_earned: number;
    total_volume: number;
    total_trades: number;
    all_time_earnings_boost_only: number;
    all_time_earnings_boost_only_usd: number;
    all_time_earnings: number;
    all_time_earnings_usd: number;
    all_weekly_earnings: number;
    all_weekly_earnings_usd: number;
}>;

declare const errorSchema: z.ZodObject<{
    status: z.ZodString;
    message: z.ZodString;
}, "strip", z.ZodTypeAny, {
    message: string;
    status: string;
}, {
    message: string;
    status: string;
}>;

declare const miniStatsSchema: z.ZodObject<{
    earned_on_referrals_token: z.ZodNumber;
    earned_on_referrals_usd: z.ZodNumber;
    token_usd: z.ZodNumber;
    registered_via_link_count: z.ZodNumber;
    earned_in_a_week_token: z.ZodNumber;
    earned_in_a_week_usd: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    earned_on_referrals_token: number;
    earned_on_referrals_usd: number;
    token_usd: number;
    registered_via_link_count: number;
    earned_in_a_week_token: number;
    earned_in_a_week_usd: number;
}, {
    earned_on_referrals_token: number;
    earned_on_referrals_usd: number;
    token_usd: number;
    registered_via_link_count: number;
    earned_in_a_week_token: number;
    earned_in_a_week_usd: number;
}>;

declare const rewardsMappingSchema: z.ZodObject<{
    data: z.ZodArray<z.ZodObject<{
        distribution: z.ZodObject<{
            dist: z.ZodObject<{
                underlying_token: z.ZodNumber;
                referers_list: z.ZodArray<z.ZodNumber, "many">;
            }, "strip", z.ZodTypeAny, {
                underlying_token: number;
                referers_list: number[];
            }, {
                underlying_token: number;
                referers_list: number[];
            }>;
            address_to_reward_mapping: z.ZodRecord<z.ZodString, z.ZodNumber>;
            ref_offset_to_rewarded_actors: z.ZodRecord<z.ZodString, z.ZodString>;
            governance_reward_only: z.ZodNumber;
            total_reward: z.ZodNumber;
            trade_initiator: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            dist: {
                underlying_token: number;
                referers_list: number[];
            };
            address_to_reward_mapping: Record<string, number>;
            ref_offset_to_rewarded_actors: Record<string, string>;
            governance_reward_only: number;
            total_reward: number;
            trade_initiator: string;
        }, {
            dist: {
                underlying_token: number;
                referers_list: number[];
            };
            address_to_reward_mapping: Record<string, number>;
            ref_offset_to_rewarded_actors: Record<string, string>;
            governance_reward_only: number;
            total_reward: number;
            trade_initiator: string;
        }>;
        timestamp_ms: z.ZodNumber;
        block_height: z.ZodNumber;
        tx_hash: z.ZodString;
        price_feed_meta_info: z.ZodNullable<z.ZodRecord<z.ZodString, z.ZodRecord<z.ZodString, z.ZodNumber>>>;
    }, "strip", z.ZodTypeAny, {
        distribution: {
            dist: {
                underlying_token: number;
                referers_list: number[];
            };
            address_to_reward_mapping: Record<string, number>;
            ref_offset_to_rewarded_actors: Record<string, string>;
            governance_reward_only: number;
            total_reward: number;
            trade_initiator: string;
        };
        timestamp_ms: number;
        block_height: number;
        tx_hash: string;
        price_feed_meta_info: Record<string, Record<string, number>> | null;
    }, {
        distribution: {
            dist: {
                underlying_token: number;
                referers_list: number[];
            };
            address_to_reward_mapping: Record<string, number>;
            ref_offset_to_rewarded_actors: Record<string, string>;
            governance_reward_only: number;
            total_reward: number;
            trade_initiator: string;
        };
        timestamp_ms: number;
        block_height: number;
        tx_hash: string;
        price_feed_meta_info: Record<string, Record<string, number>> | null;
    }>, "many">;
    pagination_info: z.ZodObject<{
        c_page: z.ZodNumber;
        t_pages: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        c_page: number;
        t_pages: number;
    }, {
        c_page: number;
        t_pages: number;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        distribution: {
            dist: {
                underlying_token: number;
                referers_list: number[];
            };
            address_to_reward_mapping: Record<string, number>;
            ref_offset_to_rewarded_actors: Record<string, string>;
            governance_reward_only: number;
            total_reward: number;
            trade_initiator: string;
        };
        timestamp_ms: number;
        block_height: number;
        tx_hash: string;
        price_feed_meta_info: Record<string, Record<string, number>> | null;
    }[];
    pagination_info: {
        c_page: number;
        t_pages: number;
    };
}, {
    data: {
        distribution: {
            dist: {
                underlying_token: number;
                referers_list: number[];
            };
            address_to_reward_mapping: Record<string, number>;
            ref_offset_to_rewarded_actors: Record<string, string>;
            governance_reward_only: number;
            total_reward: number;
            trade_initiator: string;
        };
        timestamp_ms: number;
        block_height: number;
        tx_hash: string;
        price_feed_meta_info: Record<string, Record<string, number>> | null;
    }[];
    pagination_info: {
        c_page: number;
        t_pages: number;
    };
}>;

declare const rewardsClaimedSchema: z.ZodObject<{
    referer: z.ZodString;
    amount: z.ZodString;
    signature: z.ZodString;
}, "strip", z.ZodTypeAny, {
    amount: string;
    signature: string;
    referer: string;
}, {
    amount: string;
    signature: string;
    referer: string;
}>;

declare const globalAnalyticsSchema: z.ZodObject<{
    ref_to_rewards: z.ZodRecord<z.ZodString, z.ZodNumber>;
    total_earned_by_refs: z.ZodNumber;
    total_sent_to_governance: z.ZodNumber;
    reward_dist_count_in_general: z.ZodRecord<z.ZodString, z.ZodNumber>;
    total_ref_system_actors: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    total_sent_to_governance: number;
    ref_to_rewards: Record<string, number>;
    total_earned_by_refs: number;
    reward_dist_count_in_general: Record<string, number>;
    total_ref_system_actors: number;
}, {
    total_sent_to_governance: number;
    ref_to_rewards: Record<string, number>;
    total_earned_by_refs: number;
    reward_dist_count_in_general: Record<string, number>;
    total_ref_system_actors: number;
}>;

declare const ratingSchema: z.ZodObject<{
    info: z.ZodObject<{
        weekly_boost_budget: z.ZodString;
        weekly_boost_budget_fmt: z.ZodNumber;
        monthly_boost_budget: z.ZodString;
        monthly_boost_budget_fmt: z.ZodNumber;
        displayed_boost_budget_fmt: z.ZodNumber;
        time_left_for_the_reward: z.ZodNumber;
        time_left_for_the_reward_local: z.ZodString;
        time_left_for_the_reward_utc: z.ZodString;
        personal_info: z.ZodNullable<z.ZodObject<{
            rank_id: z.ZodNumber;
            wallet: z.ZodString;
            staked_ve_token: z.ZodString;
            staked_ve_token_fmt: z.ZodNumber;
            staked_ve_token_weight: z.ZodString;
            staked_ve_token_weight_fmt: z.ZodNumber;
            weighted_volume: z.ZodString;
            weighted_volume_fmt: z.ZodNumber;
            total_weight: z.ZodString;
            total_weight_fmt: z.ZodNumber;
            reward: z.ZodString;
            reward_fmt: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            wallet: string;
            reward: string;
            rank_id: number;
            staked_ve_token: string;
            staked_ve_token_fmt: number;
            staked_ve_token_weight: string;
            staked_ve_token_weight_fmt: number;
            weighted_volume: string;
            weighted_volume_fmt: number;
            total_weight: string;
            total_weight_fmt: number;
            reward_fmt: number;
        }, {
            wallet: string;
            reward: string;
            rank_id: number;
            staked_ve_token: string;
            staked_ve_token_fmt: number;
            staked_ve_token_weight: string;
            staked_ve_token_weight_fmt: number;
            weighted_volume: string;
            weighted_volume_fmt: number;
            total_weight: string;
            total_weight_fmt: number;
            reward_fmt: number;
        }>>;
    }, "strip", z.ZodTypeAny, {
        weekly_boost_budget: string;
        weekly_boost_budget_fmt: number;
        monthly_boost_budget: string;
        monthly_boost_budget_fmt: number;
        displayed_boost_budget_fmt: number;
        time_left_for_the_reward: number;
        time_left_for_the_reward_local: string;
        time_left_for_the_reward_utc: string;
        personal_info: {
            wallet: string;
            reward: string;
            rank_id: number;
            staked_ve_token: string;
            staked_ve_token_fmt: number;
            staked_ve_token_weight: string;
            staked_ve_token_weight_fmt: number;
            weighted_volume: string;
            weighted_volume_fmt: number;
            total_weight: string;
            total_weight_fmt: number;
            reward_fmt: number;
        } | null;
    }, {
        weekly_boost_budget: string;
        weekly_boost_budget_fmt: number;
        monthly_boost_budget: string;
        monthly_boost_budget_fmt: number;
        displayed_boost_budget_fmt: number;
        time_left_for_the_reward: number;
        time_left_for_the_reward_local: string;
        time_left_for_the_reward_utc: string;
        personal_info: {
            wallet: string;
            reward: string;
            rank_id: number;
            staked_ve_token: string;
            staked_ve_token_fmt: number;
            staked_ve_token_weight: string;
            staked_ve_token_weight_fmt: number;
            weighted_volume: string;
            weighted_volume_fmt: number;
            total_weight: string;
            total_weight_fmt: number;
            reward_fmt: number;
        } | null;
    }>;
    list: z.ZodArray<z.ZodObject<{
        rank_id: z.ZodNumber;
        wallet: z.ZodString;
        staked_ve_token: z.ZodString;
        staked_ve_token_fmt: z.ZodNumber;
        staked_ve_token_weight: z.ZodString;
        staked_ve_token_weight_fmt: z.ZodNumber;
        weighted_volume: z.ZodString;
        weighted_volume_fmt: z.ZodNumber;
        total_weight: z.ZodString;
        total_weight_fmt: z.ZodNumber;
        total_volume_fmt: z.ZodNumber;
        weekly_earnings_fmt: z.ZodNumber;
        total_earnings_fmt: z.ZodNumber;
        referrals_count_fmt: z.ZodNumber;
        total_trades_fmt: z.ZodNumber;
        reward: z.ZodString;
        reward_fmt: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        wallet: string;
        reward: string;
        rank_id: number;
        staked_ve_token: string;
        staked_ve_token_fmt: number;
        staked_ve_token_weight: string;
        staked_ve_token_weight_fmt: number;
        weighted_volume: string;
        weighted_volume_fmt: number;
        total_weight: string;
        total_weight_fmt: number;
        reward_fmt: number;
        total_volume_fmt: number;
        weekly_earnings_fmt: number;
        total_earnings_fmt: number;
        referrals_count_fmt: number;
        total_trades_fmt: number;
    }, {
        wallet: string;
        reward: string;
        rank_id: number;
        staked_ve_token: string;
        staked_ve_token_fmt: number;
        staked_ve_token_weight: string;
        staked_ve_token_weight_fmt: number;
        weighted_volume: string;
        weighted_volume_fmt: number;
        total_weight: string;
        total_weight_fmt: number;
        reward_fmt: number;
        total_volume_fmt: number;
        weekly_earnings_fmt: number;
        total_earnings_fmt: number;
        referrals_count_fmt: number;
        total_trades_fmt: number;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    info: {
        weekly_boost_budget: string;
        weekly_boost_budget_fmt: number;
        monthly_boost_budget: string;
        monthly_boost_budget_fmt: number;
        displayed_boost_budget_fmt: number;
        time_left_for_the_reward: number;
        time_left_for_the_reward_local: string;
        time_left_for_the_reward_utc: string;
        personal_info: {
            wallet: string;
            reward: string;
            rank_id: number;
            staked_ve_token: string;
            staked_ve_token_fmt: number;
            staked_ve_token_weight: string;
            staked_ve_token_weight_fmt: number;
            weighted_volume: string;
            weighted_volume_fmt: number;
            total_weight: string;
            total_weight_fmt: number;
            reward_fmt: number;
        } | null;
    };
    list: {
        wallet: string;
        reward: string;
        rank_id: number;
        staked_ve_token: string;
        staked_ve_token_fmt: number;
        staked_ve_token_weight: string;
        staked_ve_token_weight_fmt: number;
        weighted_volume: string;
        weighted_volume_fmt: number;
        total_weight: string;
        total_weight_fmt: number;
        reward_fmt: number;
        total_volume_fmt: number;
        weekly_earnings_fmt: number;
        total_earnings_fmt: number;
        referrals_count_fmt: number;
        total_trades_fmt: number;
    }[];
}, {
    info: {
        weekly_boost_budget: string;
        weekly_boost_budget_fmt: number;
        monthly_boost_budget: string;
        monthly_boost_budget_fmt: number;
        displayed_boost_budget_fmt: number;
        time_left_for_the_reward: number;
        time_left_for_the_reward_local: string;
        time_left_for_the_reward_utc: string;
        personal_info: {
            wallet: string;
            reward: string;
            rank_id: number;
            staked_ve_token: string;
            staked_ve_token_fmt: number;
            staked_ve_token_weight: string;
            staked_ve_token_weight_fmt: number;
            weighted_volume: string;
            weighted_volume_fmt: number;
            total_weight: string;
            total_weight_fmt: number;
            reward_fmt: number;
        } | null;
    };
    list: {
        wallet: string;
        reward: string;
        rank_id: number;
        staked_ve_token: string;
        staked_ve_token_fmt: number;
        staked_ve_token_weight: string;
        staked_ve_token_weight_fmt: number;
        weighted_volume: string;
        weighted_volume_fmt: number;
        total_weight: string;
        total_weight_fmt: number;
        reward_fmt: number;
        total_volume_fmt: number;
        weekly_earnings_fmt: number;
        total_earnings_fmt: number;
        referrals_count_fmt: number;
        total_trades_fmt: number;
    }[];
}>;

declare const claimInfoSchema: z.ZodObject<{
    global: z.ZodObject<{
        total_non_accrued: z.ZodNumber;
        total_non_accrued_token: z.ZodNumber;
        total_non_accrued_usd: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
    }, {
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
    }>;
    chain_to_reward_info: z.ZodRecord<z.ZodString, z.ZodObject<{
        total_accrued: z.ZodNumber;
        total_accrued_token: z.ZodNumber;
        total_accrued_usd: z.ZodNumber;
        total_non_accrued: z.ZodNumber;
        total_non_accrued_token: z.ZodNumber;
        total_non_accrued_usd: z.ZodNumber;
        total_earned: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        total_earned: number;
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
        total_accrued: number;
        total_accrued_token: number;
        total_accrued_usd: number;
    }, {
        total_earned: number;
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
        total_accrued: number;
        total_accrued_token: number;
        total_accrued_usd: number;
    }>>;
    mini_stats: z.ZodObject<{
        earned_on_referrals_token: z.ZodNumber;
        earned_on_referrals_usd: z.ZodNumber;
        token_usd: z.ZodNumber;
        registered_via_link_count: z.ZodNumber;
        earned_in_a_week_token: z.ZodNumber;
        earned_in_a_week_usd: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        earned_on_referrals_token: number;
        earned_on_referrals_usd: number;
        token_usd: number;
        registered_via_link_count: number;
        earned_in_a_week_token: number;
        earned_in_a_week_usd: number;
    }, {
        earned_on_referrals_token: number;
        earned_on_referrals_usd: number;
        token_usd: number;
        registered_via_link_count: number;
        earned_in_a_week_token: number;
        earned_in_a_week_usd: number;
    }>;
}, "strip", z.ZodTypeAny, {
    global: {
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
    };
    chain_to_reward_info: Record<string, {
        total_earned: number;
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
        total_accrued: number;
        total_accrued_token: number;
        total_accrued_usd: number;
    }>;
    mini_stats: {
        earned_on_referrals_token: number;
        earned_on_referrals_usd: number;
        token_usd: number;
        registered_via_link_count: number;
        earned_in_a_week_token: number;
        earned_in_a_week_usd: number;
    };
}, {
    global: {
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
    };
    chain_to_reward_info: Record<string, {
        total_earned: number;
        total_non_accrued: number;
        total_non_accrued_token: number;
        total_non_accrued_usd: number;
        total_accrued: number;
        total_accrued_token: number;
        total_accrued_usd: number;
    }>;
    mini_stats: {
        earned_on_referrals_token: number;
        earned_on_referrals_usd: number;
        token_usd: number;
        registered_via_link_count: number;
        earned_in_a_week_token: number;
        earned_in_a_week_usd: number;
    };
}>;

declare const aggregatedHistorySchema: z.ZodObject<{
    data: z.ZodArray<z.ZodObject<{
        history_type: z.ZodString;
        chain_type: z.ZodString;
        chain_comp: z.ZodString;
        chain_id: z.ZodNumber;
        date_unix: z.ZodNumber;
        date_time_local: z.ZodString;
        date_time_utc: z.ZodString;
        amount_token: z.ZodString;
        amount_token_fmt: z.ZodNumber;
        amount_usd: z.ZodString;
        amount_usd_fmt: z.ZodNumber;
        token_price: z.ZodString;
        token_price_fmt: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        history_type: string;
        chain_type: string;
        chain_comp: string;
        chain_id: number;
        date_unix: number;
        date_time_local: string;
        date_time_utc: string;
        amount_token: string;
        amount_token_fmt: number;
        amount_usd: string;
        amount_usd_fmt: number;
        token_price: string;
        token_price_fmt: number;
    }, {
        history_type: string;
        chain_type: string;
        chain_comp: string;
        chain_id: number;
        date_unix: number;
        date_time_local: string;
        date_time_utc: string;
        amount_token: string;
        amount_token_fmt: number;
        amount_usd: string;
        amount_usd_fmt: number;
        token_price: string;
        token_price_fmt: number;
    }>, "many">;
    pagination_info: z.ZodObject<{
        c_page: z.ZodNumber;
        t_pages: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        c_page: number;
        t_pages: number;
    }, {
        c_page: number;
        t_pages: number;
    }>;
}, "strip", z.ZodTypeAny, {
    data: {
        history_type: string;
        chain_type: string;
        chain_comp: string;
        chain_id: number;
        date_unix: number;
        date_time_local: string;
        date_time_utc: string;
        amount_token: string;
        amount_token_fmt: number;
        amount_usd: string;
        amount_usd_fmt: number;
        token_price: string;
        token_price_fmt: number;
    }[];
    pagination_info: {
        c_page: number;
        t_pages: number;
    };
}, {
    data: {
        history_type: string;
        chain_type: string;
        chain_comp: string;
        chain_id: number;
        date_unix: number;
        date_time_local: string;
        date_time_utc: string;
        amount_token: string;
        amount_token_fmt: number;
        amount_usd: string;
        amount_usd_fmt: number;
        token_price: string;
        token_price_fmt: number;
    }[];
    pagination_info: {
        c_page: number;
        t_pages: number;
    };
}>;

declare const contractsAddressesSchema: z.ZodRecord<z.ZodNativeEnum<typeof SupportedChainId>, z.ZodEffects<z.ZodString, string, string>>;

declare const inviteCodeLinkSchema: z.ZodObject<{
    link: z.ZodNullable<z.ZodObject<{
        referer: z.ZodString;
        ref_link: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        referer: string;
        ref_link: string;
    }, {
        referer: string;
        ref_link: string;
    }>>;
    invite: z.ZodNullable<z.ZodObject<{
        code: z.ZodString;
        data: z.ZodNull;
        limits: z.ZodObject<{
            tag: z.ZodString;
            max_invites: z.ZodNumber;
            max_ref_depth: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            tag: string;
            max_invites: number;
            max_ref_depth: number;
        }, {
            tag: string;
            max_invites: number;
            max_ref_depth: number;
        }>;
    }, "strip", z.ZodTypeAny, {
        code: string;
        data: null;
        limits: {
            tag: string;
            max_invites: number;
            max_ref_depth: number;
        };
    }, {
        code: string;
        data: null;
        limits: {
            tag: string;
            max_invites: number;
            max_ref_depth: number;
        };
    }>>;
}, "strip", z.ZodTypeAny, {
    link: {
        referer: string;
        ref_link: string;
    } | null;
    invite: {
        code: string;
        data: null;
        limits: {
            tag: string;
            max_invites: number;
            max_ref_depth: number;
        };
    } | null;
}, {
    link: {
        referer: string;
        ref_link: string;
    } | null;
    invite: {
        code: string;
        data: null;
        limits: {
            tag: string;
            max_invites: number;
            max_ref_depth: number;
        };
    } | null;
}>;

declare const allTimeLeadersSchema: z.ZodArray<z.ZodObject<{
    wallet: z.ZodString;
    total_earnings_fmt: z.ZodNumber;
    referrals_count_fmt: z.ZodNumber;
    total_trades_fmt: z.ZodNumber;
    weekly_earnings_fmt: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    wallet: string;
    weekly_earnings_fmt: number;
    total_earnings_fmt: number;
    referrals_count_fmt: number;
    total_trades_fmt: number;
}, {
    wallet: string;
    weekly_earnings_fmt: number;
    total_earnings_fmt: number;
    referrals_count_fmt: number;
    total_trades_fmt: number;
}>, "many">;

declare const index$6_aggregatedHistorySchema: typeof aggregatedHistorySchema;
declare const index$6_allTimeLeadersSchema: typeof allTimeLeadersSchema;
declare const index$6_claimInfoSchema: typeof claimInfoSchema;
declare const index$6_contractsAddressesSchema: typeof contractsAddressesSchema;
declare const index$6_distinctAnalyticsSchema: typeof distinctAnalyticsSchema;
declare const index$6_errorSchema: typeof errorSchema;
declare const index$6_globalAnalyticsSchema: typeof globalAnalyticsSchema;
declare const index$6_inviteCodeLinkSchema: typeof inviteCodeLinkSchema;
declare const index$6_linkSchema: typeof linkSchema;
declare const index$6_miniStatsSchema: typeof miniStatsSchema;
declare const index$6_ratingSchema: typeof ratingSchema;
declare const index$6_rewardsClaimedSchema: typeof rewardsClaimedSchema;
declare const index$6_rewardsMappingSchema: typeof rewardsMappingSchema;
declare namespace index$6 {
    export {
        index$6_aggregatedHistorySchema as aggregatedHistorySchema,
        index$6_allTimeLeadersSchema as allTimeLeadersSchema,
        index$6_claimInfoSchema as claimInfoSchema,
        index$6_contractsAddressesSchema as contractsAddressesSchema,
        index$6_distinctAnalyticsSchema as distinctAnalyticsSchema,
        index$6_errorSchema as errorSchema,
        index$6_globalAnalyticsSchema as globalAnalyticsSchema,
        index$6_inviteCodeLinkSchema as inviteCodeLinkSchema,
        index$6_linkSchema as linkSchema,
        index$6_miniStatsSchema as miniStatsSchema,
        index$6_ratingSchema as ratingSchema,
        index$6_rewardsClaimedSchema as rewardsClaimedSchema,
        index$6_rewardsMappingSchema as rewardsMappingSchema,
    };
}

type CreateLinkPayloadType = {
    referer: string;
    link_option: number;
};
type ClaimRewardsPayload = {
    reward_recipient: string;
    chain_id: number;
};
type SubmitInviteCodekWithLinkPayload = {
    inviteCode: string;
    referer: string;
};
type SubscribePayloadType = {
    ref_target: string;
    referral: string;
};
type SignatureType = {
    signature: string;
};
type submitTransactionDataForWidgetPayload = {
    partner_domain: string;
    sender_address: string;
    tx_hash: string;
    chain_id: number;
    signature: string;
};
declare class ReferralSystem {
    private readonly apiUrl;
    get api(): string;
    constructor(apiUrl: string);
    getLink: (refererAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            status: string;
            referer: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            status: string;
            referer: string;
        }>;
    }>>;
    getMyReferral: (myWalletAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            status: string;
            referer: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            status: string;
            referer: string;
        }>;
    }>>;
    getMyInviteCodeAndLink: (refererAddress: string, suppressError?: boolean) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            link: {
                referer: string;
                ref_link: string;
            } | null;
            invite: {
                code: string;
                data: null;
                limits: {
                    tag: string;
                    max_invites: number;
                    max_ref_depth: number;
                };
            } | null;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            link: {
                referer: string;
                ref_link: string;
            } | null;
            invite: {
                code: string;
                data: null;
                limits: {
                    tag: string;
                    max_invites: number;
                    max_ref_depth: number;
                };
            } | null;
        }>;
    }>>;
    submitInviteCodeWithLink: ({ inviteCode, referer, }: SubmitInviteCodekWithLinkPayload) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            link: {
                referer: string;
                ref_link: string;
            } | null;
            invite: {
                code: string;
                data: null;
                limits: {
                    tag: string;
                    max_invites: number;
                    max_ref_depth: number;
                };
            } | null;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            link: {
                referer: string;
                ref_link: string;
            } | null;
            invite: {
                code: string;
                data: null;
                limits: {
                    tag: string;
                    max_invites: number;
                    max_ref_depth: number;
                };
            } | null;
        }>;
    }>>;
    getDistinctAnalytics: (refererAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            referer: string;
            refs_info: Record<string, {
                timestamp: number;
                referral_address: string;
                referral_earned_fees: number;
                referer_earned_fees: number;
                relative_ref_level: number;
                reward_record_hash: string;
                latest_timestamp: number;
                latest_block: number;
            }>;
            total_sent_to_governance: number;
            total_earned: number;
            total_volume: number;
            total_trades: number;
            all_time_earnings_boost_only: number;
            all_time_earnings_boost_only_usd: number;
            all_time_earnings: number;
            all_time_earnings_usd: number;
            all_weekly_earnings: number;
            all_weekly_earnings_usd: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            referer: string;
            refs_info: Record<string, {
                timestamp: number;
                referral_address: string;
                referral_earned_fees: number;
                referer_earned_fees: number;
                relative_ref_level: number;
                reward_record_hash: string;
                latest_timestamp: number;
                latest_block: number;
            }>;
            total_sent_to_governance: number;
            total_earned: number;
            total_volume: number;
            total_trades: number;
            all_time_earnings_boost_only: number;
            all_time_earnings_boost_only_usd: number;
            all_time_earnings: number;
            all_time_earnings_usd: number;
            all_weekly_earnings: number;
            all_weekly_earnings_usd: number;
        }>;
    }>>;
    getGlobalAnalytics: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            total_sent_to_governance: number;
            ref_to_rewards: Record<string, number>;
            total_earned_by_refs: number;
            reward_dist_count_in_general: Record<string, number>;
            total_ref_system_actors: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            total_sent_to_governance: number;
            ref_to_rewards: Record<string, number>;
            total_earned_by_refs: number;
            reward_dist_count_in_general: Record<string, number>;
            total_ref_system_actors: number;
        }>;
    }>>;
    /**
     * @param refererAddress Address without 0x prefix
     */
    getMiniStats: (refererAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            earned_on_referrals_token: number;
            earned_on_referrals_usd: number;
            token_usd: number;
            registered_via_link_count: number;
            earned_in_a_week_token: number;
            earned_in_a_week_usd: number;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            earned_on_referrals_token: number;
            earned_on_referrals_usd: number;
            token_usd: number;
            registered_via_link_count: number;
            earned_in_a_week_token: number;
            earned_in_a_week_usd: number;
        }>;
    }>>;
    getRewardsMapping: (referralAddress: string, page?: number, positionsPerPage?: number) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            data: {
                distribution: {
                    dist: {
                        underlying_token: number;
                        referers_list: number[];
                    };
                    address_to_reward_mapping: Record<string, number>;
                    ref_offset_to_rewarded_actors: Record<string, string>;
                    governance_reward_only: number;
                    total_reward: number;
                    trade_initiator: string;
                };
                timestamp_ms: number;
                block_height: number;
                tx_hash: string;
                price_feed_meta_info: Record<string, Record<string, number>> | null;
            }[];
            pagination_info: {
                c_page: number;
                t_pages: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            data: {
                distribution: {
                    dist: {
                        underlying_token: number;
                        referers_list: number[];
                    };
                    address_to_reward_mapping: Record<string, number>;
                    ref_offset_to_rewarded_actors: Record<string, string>;
                    governance_reward_only: number;
                    total_reward: number;
                    trade_initiator: string;
                };
                timestamp_ms: number;
                block_height: number;
                tx_hash: string;
                price_feed_meta_info: Record<string, Record<string, number>> | null;
            }[];
            pagination_info: {
                c_page: number;
                t_pages: number;
            };
        }>;
    }>>;
    claimRewards: (payload: ClaimRewardsPayload, signature: SignatureType) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            amount: string;
            signature: string;
            referer: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            amount: string;
            signature: string;
            referer: string;
        }>;
    }>>;
    createReferralLink: (payload: CreateLinkPayloadType) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            status: string;
            referer: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            status: string;
            referer: string;
        }>;
    }>>;
    subscribeToReferral: (payload: SubscribePayloadType) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            status: string;
            referer: string;
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            status: string;
            referer: string;
        }>;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }>>;
    getLeaderboard: (refererAddress: string | undefined) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                weekly_boost_budget: string;
                weekly_boost_budget_fmt: number;
                monthly_boost_budget: string;
                monthly_boost_budget_fmt: number;
                displayed_boost_budget_fmt: number;
                time_left_for_the_reward: number;
                time_left_for_the_reward_local: string;
                time_left_for_the_reward_utc: string;
                personal_info: {
                    wallet: string;
                    reward: string;
                    rank_id: number;
                    staked_ve_token: string;
                    staked_ve_token_fmt: number;
                    staked_ve_token_weight: string;
                    staked_ve_token_weight_fmt: number;
                    weighted_volume: string;
                    weighted_volume_fmt: number;
                    total_weight: string;
                    total_weight_fmt: number;
                    reward_fmt: number;
                } | null;
            };
            list: {
                wallet: string;
                reward: string;
                rank_id: number;
                staked_ve_token: string;
                staked_ve_token_fmt: number;
                staked_ve_token_weight: string;
                staked_ve_token_weight_fmt: number;
                weighted_volume: string;
                weighted_volume_fmt: number;
                total_weight: string;
                total_weight_fmt: number;
                reward_fmt: number;
                total_volume_fmt: number;
                weekly_earnings_fmt: number;
                total_earnings_fmt: number;
                referrals_count_fmt: number;
                total_trades_fmt: number;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            info: {
                weekly_boost_budget: string;
                weekly_boost_budget_fmt: number;
                monthly_boost_budget: string;
                monthly_boost_budget_fmt: number;
                displayed_boost_budget_fmt: number;
                time_left_for_the_reward: number;
                time_left_for_the_reward_local: string;
                time_left_for_the_reward_utc: string;
                personal_info: {
                    wallet: string;
                    reward: string;
                    rank_id: number;
                    staked_ve_token: string;
                    staked_ve_token_fmt: number;
                    staked_ve_token_weight: string;
                    staked_ve_token_weight_fmt: number;
                    weighted_volume: string;
                    weighted_volume_fmt: number;
                    total_weight: string;
                    total_weight_fmt: number;
                    reward_fmt: number;
                } | null;
            };
            list: {
                wallet: string;
                reward: string;
                rank_id: number;
                staked_ve_token: string;
                staked_ve_token_fmt: number;
                staked_ve_token_weight: string;
                staked_ve_token_weight_fmt: number;
                weighted_volume: string;
                weighted_volume_fmt: number;
                total_weight: string;
                total_weight_fmt: number;
                reward_fmt: number;
                total_volume_fmt: number;
                weekly_earnings_fmt: number;
                total_earnings_fmt: number;
                referrals_count_fmt: number;
                total_trades_fmt: number;
            }[];
        }>;
    }>>;
    getLeaderboardSingleChain: (refererAddress: string | undefined, chainId: SupportedChainId) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            info: {
                weekly_boost_budget: string;
                weekly_boost_budget_fmt: number;
                monthly_boost_budget: string;
                monthly_boost_budget_fmt: number;
                displayed_boost_budget_fmt: number;
                time_left_for_the_reward: number;
                time_left_for_the_reward_local: string;
                time_left_for_the_reward_utc: string;
                personal_info: {
                    wallet: string;
                    reward: string;
                    rank_id: number;
                    staked_ve_token: string;
                    staked_ve_token_fmt: number;
                    staked_ve_token_weight: string;
                    staked_ve_token_weight_fmt: number;
                    weighted_volume: string;
                    weighted_volume_fmt: number;
                    total_weight: string;
                    total_weight_fmt: number;
                    reward_fmt: number;
                } | null;
            };
            list: {
                wallet: string;
                reward: string;
                rank_id: number;
                staked_ve_token: string;
                staked_ve_token_fmt: number;
                staked_ve_token_weight: string;
                staked_ve_token_weight_fmt: number;
                weighted_volume: string;
                weighted_volume_fmt: number;
                total_weight: string;
                total_weight_fmt: number;
                reward_fmt: number;
                total_volume_fmt: number;
                weekly_earnings_fmt: number;
                total_earnings_fmt: number;
                referrals_count_fmt: number;
                total_trades_fmt: number;
            }[];
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            info: {
                weekly_boost_budget: string;
                weekly_boost_budget_fmt: number;
                monthly_boost_budget: string;
                monthly_boost_budget_fmt: number;
                displayed_boost_budget_fmt: number;
                time_left_for_the_reward: number;
                time_left_for_the_reward_local: string;
                time_left_for_the_reward_utc: string;
                personal_info: {
                    wallet: string;
                    reward: string;
                    rank_id: number;
                    staked_ve_token: string;
                    staked_ve_token_fmt: number;
                    staked_ve_token_weight: string;
                    staked_ve_token_weight_fmt: number;
                    weighted_volume: string;
                    weighted_volume_fmt: number;
                    total_weight: string;
                    total_weight_fmt: number;
                    reward_fmt: number;
                } | null;
            };
            list: {
                wallet: string;
                reward: string;
                rank_id: number;
                staked_ve_token: string;
                staked_ve_token_fmt: number;
                staked_ve_token_weight: string;
                staked_ve_token_weight_fmt: number;
                weighted_volume: string;
                weighted_volume_fmt: number;
                total_weight: string;
                total_weight_fmt: number;
                reward_fmt: number;
                total_volume_fmt: number;
                weekly_earnings_fmt: number;
                total_earnings_fmt: number;
                referrals_count_fmt: number;
                total_trades_fmt: number;
            }[];
        }>;
    }>>;
    getAllTimeLeaders: (refererAddress: string | undefined) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            wallet: string;
            weekly_earnings_fmt: number;
            total_earnings_fmt: number;
            referrals_count_fmt: number;
            total_trades_fmt: number;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            wallet: string;
            weekly_earnings_fmt: number;
            total_earnings_fmt: number;
            referrals_count_fmt: number;
            total_trades_fmt: number;
        }[]>;
    }>>;
    getContractsAddresses: () => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: Partial<Record<SupportedChainId, string>>;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<Partial<Record<SupportedChainId, string>>>;
    }>>;
    getClaimInfo: (refererAddress: string) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            global: {
                total_non_accrued: number;
                total_non_accrued_token: number;
                total_non_accrued_usd: number;
            };
            chain_to_reward_info: Record<string, {
                total_earned: number;
                total_non_accrued: number;
                total_non_accrued_token: number;
                total_non_accrued_usd: number;
                total_accrued: number;
                total_accrued_token: number;
                total_accrued_usd: number;
            }>;
            mini_stats: {
                earned_on_referrals_token: number;
                earned_on_referrals_usd: number;
                token_usd: number;
                registered_via_link_count: number;
                earned_in_a_week_token: number;
                earned_in_a_week_usd: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            global: {
                total_non_accrued: number;
                total_non_accrued_token: number;
                total_non_accrued_usd: number;
            };
            chain_to_reward_info: Record<string, {
                total_earned: number;
                total_non_accrued: number;
                total_non_accrued_token: number;
                total_non_accrued_usd: number;
                total_accrued: number;
                total_accrued_token: number;
                total_accrued_usd: number;
            }>;
            mini_stats: {
                earned_on_referrals_token: number;
                earned_on_referrals_usd: number;
                token_usd: number;
                registered_via_link_count: number;
                earned_in_a_week_token: number;
                earned_in_a_week_usd: number;
            };
        }>;
    }>>;
    getAggregatedHistory: (refererAddress: string, chainId: SupportedChainId | undefined, types: string[] | undefined, itemPerPage: number, page: number) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: {
            message: string;
            status: string;
        };
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<{
            message: string;
            status: string;
        }>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            data: {
                history_type: string;
                chain_type: string;
                chain_comp: string;
                chain_id: number;
                date_unix: number;
                date_time_local: string;
                date_time_utc: string;
                amount_token: string;
                amount_token_fmt: number;
                amount_usd: string;
                amount_usd_fmt: number;
                token_price: string;
                token_price_fmt: number;
            }[];
            pagination_info: {
                c_page: number;
                t_pages: number;
            };
        };
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<{
            data: {
                history_type: string;
                chain_type: string;
                chain_comp: string;
                chain_id: number;
                date_unix: number;
                date_time_local: string;
                date_time_utc: string;
                amount_token: string;
                amount_token_fmt: number;
                amount_usd: string;
                amount_usd_fmt: number;
                token_price: string;
                token_price_fmt: number;
            }[];
            pagination_info: {
                c_page: number;
                t_pages: number;
            };
        }>;
    }>>;
    submitTransactionDataForWidget: (payload: submitTransactionDataForWidgetPayload) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: z.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: unknown;
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: z.ZodError<unknown>;
    }>>;
}

type index$5_ReferralSystem = ReferralSystem;
declare const index$5_ReferralSystem: typeof ReferralSystem;
declare namespace index$5 {
    export {
        index$5_ReferralSystem as ReferralSystem,
        index$6 as schemas,
    };
}

declare class Bridge {
    private readonly unitsArray;
    readonly EXTERNAL_ATOMICS_DATA_CACHE_TIME_MS: number;
    private externalAtomicSwaps;
    readonly ADDRESS_TO_ASSET_CACHE_TIME_MS: number;
    private addressToAsset;
    constructor(unitsArray: Unit[]);
    registerRedeemOrder(secretHash: string, redeemOrder: RedeemOrder): void;
    getCombinedAddressToAsset(): Promise<Partial<Record<string, Partial<Record<SupportedChainId, string>>>>>;
    combineLocalAndExternalData(walletAddress: string, localAtomicSwaps: AtomicSwapLocal[], transactions: TransactionInfo[]): Promise<Map<string, AtomicSwap>>;
    makeAtomicSwap(walletAddress: string, networkFrom: SupportedChainId, networkTo: SupportedChainId, amount: string, asset: string, env?: string | undefined): {
        sourceChainId: SupportedChainId;
        targetChainId: SupportedChainId;
        amount: string;
        walletAddress: string;
        secret: string;
        secretHash: string;
        assetName: string;
        creationDate: number;
        lockExpiration: number;
        env: string | undefined;
    };
    getHistory(address: string, limit?: number): Promise<Partial<Record<string, {
        creationDate: Date;
        sourceChainId: SupportedChainId;
        targetChainId: SupportedChainId;
        used: boolean;
        claimed: boolean;
        isAggApplied: boolean;
        asset: string;
        sender: string;
        secretHash: string;
        receiver?: string | undefined;
        secret?: string | undefined;
        timestamp: ({
            redeem?: number | undefined;
        } & {
            lock?: number | undefined;
            claim?: number | undefined;
            refund?: number | undefined;
        }) | undefined;
        expiration: ({
            redeem?: number | undefined;
        } & {
            lock?: number | undefined;
        }) | undefined;
        transactions: ({
            redeem?: string | undefined;
        } & {
            lock?: string | undefined;
            claim?: string | undefined;
            refund?: string | undefined;
        }) | undefined;
        lockOrder?: {
            amount: number;
            asset: string;
            expiration: number;
            secretHash: string;
            sender: string;
            used: boolean;
            sourceNetworkCode: "ETH" | "BSC" | "FTM" | "OKC" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";
        } | undefined;
        redeemOrder?: {
            amount: number;
            asset: string;
            expiration: number;
            receiver: string;
            secretHash: string;
            sender: string;
            signature: string;
            claimReceiver: string;
        } | undefined;
        amountToReceive: number | undefined;
        amountToSpend: number | undefined;
        status: {
            source?: "BEFORE-LOCK" | "LOCKED" | "REFUNDED" | "CLAIMED" | undefined;
            target?: "BEFORE-REDEEM" | "REDEEMED" | undefined;
            aggregator?: "SETTLED" | "EXPIRED" | "ACTIVE" | undefined;
        };
    }>>>;
    swap(assetName: string, amount: BigNumber.Value, sourceChain: SupportedChainId, targetChain: SupportedChainId, signer: ethers.Signer, options: {
        autoApprove?: boolean;
        logger?: (message: string) => void;
        withdrawToWallet?: boolean;
    }): Promise<void>;
}

declare const tickerSchema: z.ZodObject<{
    pair: z.ZodString;
    volume24: z.ZodNumber;
    change24: z.ZodNumber;
    lastPrice: z.ZodNumber;
    pricePrecision: z.ZodNumber;
    networks: z.ZodArray<z.ZodNativeEnum<typeof SupportedChainId>, "many">;
}, "strip", z.ZodTypeAny, {
    pricePrecision: number;
    networks: SupportedChainId[];
    pair: string;
    volume24: number;
    change24: number;
    lastPrice: number;
}, {
    pricePrecision: number;
    networks: SupportedChainId[];
    pair: string;
    volume24: number;
    change24: number;
    lastPrice: number;
}>;
declare const tickersSchema: z.ZodArray<z.ZodObject<{
    pair: z.ZodString;
    volume24: z.ZodNumber;
    change24: z.ZodNumber;
    lastPrice: z.ZodNumber;
    pricePrecision: z.ZodNumber;
    networks: z.ZodArray<z.ZodNativeEnum<typeof SupportedChainId>, "many">;
}, "strip", z.ZodTypeAny, {
    pricePrecision: number;
    networks: SupportedChainId[];
    pair: string;
    volume24: number;
    change24: number;
    lastPrice: number;
}, {
    pricePrecision: number;
    networks: SupportedChainId[];
    pair: string;
    volume24: number;
    change24: number;
    lastPrice: number;
}>, "many">;

declare const index$4_tickerSchema: typeof tickerSchema;
declare const index$4_tickersSchema: typeof tickersSchema;
declare namespace index$4 {
    export {
        index$4_tickerSchema as tickerSchema,
        index$4_tickersSchema as tickersSchema,
    };
}

declare class Frontage {
    private readonly apiUrl;
    constructor(apiUrl: string);
    searchTickers: ({ searchValue, currentNetwork, targetNetwork, sortBy, sortType, offset, limit, }: {
        searchValue: string;
    } & TickersBaseSearchParams) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            pricePrecision: number;
            networks: SupportedChainId[];
            pair: string;
            volume24: number;
            change24: number;
            lastPrice: number;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            pricePrecision: number;
            networks: SupportedChainId[];
            pair: string;
            volume24: number;
            change24: number;
            lastPrice: number;
        }[]>;
    }>>;
    getTickers: ({ category, currentNetwork, targetNetwork, sortBy, sortType, offset, limit, tickers, }: {
        category: TickersCategories;
        tickers?: string;
    } & TickersBaseSearchParams) => Promise<neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "fetchError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: undefined;
        type: "unknownFetchThrow";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "unknownGetTextUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "serverError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseError";
        url: string;
        message: string;
        error: Error;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "jsonParseUnknownError";
        url: string;
        message: string;
        error: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientError";
        url: string;
        message: string;
        text: string;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorWithResponsePayload";
        url: string;
        message: string;
        payload: unknown;
    }> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "clientErrorPayloadParseError";
        url: string;
        message: string;
        text: string;
        error: zod.ZodError<unknown>;
    }> | neverthrow.Ok<{
        response: Response;
        data: {
            pricePrecision: number;
            networks: SupportedChainId[];
            pair: string;
            volume24: number;
            change24: number;
            lastPrice: number;
        }[];
    }, never> | neverthrow.Err<never, {
        requestOptions: {
            headers: HeadersInit;
            body?: BodyInit | null;
            cache?: RequestCache;
            credentials?: RequestCredentials;
            integrity?: string;
            keepalive?: boolean;
            method?: string;
            mode?: RequestMode;
            redirect?: RequestRedirect;
            referrer?: string;
            referrerPolicy?: ReferrerPolicy;
            signal?: AbortSignal | null;
            window?: null;
        };
        response: Response;
        type: "payloadParseError";
        url: string;
        message: string;
        error: zod.ZodError<{
            pricePrecision: number;
            networks: SupportedChainId[];
            pair: string;
            volume24: number;
            change24: number;
            lastPrice: number;
        }[]>;
    }>>;
}

type index$3_Frontage = Frontage;
declare const index$3_Frontage: typeof Frontage;
declare namespace index$3 {
    export {
        index$3_Frontage as Frontage,
        index$4 as schemas,
    };
}

declare class Orion {
    readonly env?: string;
    readonly units: Partial<Record<SupportedChainId, Unit>>;
    readonly referralSystem: ReferralSystem;
    readonly bridge: Bridge;
    readonly frontage: Frontage;
    logger: ((message: string) => void) | undefined;
    constructor(envOrConfig?: KnownEnv | EnvConfig, overrides?: DeepPartial<EnvConfig>, logger?: ((message: string) => void) | undefined);
    get unitsArray(): Unit[];
    getUnit(networkCodeOrChainId: typeof _default$3[number] | SupportedChainId): Unit;
    getSiblingsOf(chainId: SupportedChainId): Unit[];
    getAssets(tradableOnly?: boolean): Promise<Partial<Record<string, Partial<Record<SupportedChainId, {
        address: string;
    }>>>>>;
    getPairs(...params: Parameters<Unit['aggregator']['getPairsList']>): Promise<Partial<Record<string, SupportedChainId[]>>>;
}

declare const calculateFeeInFeeAsset: (amount: BigNumber.Value, gasPriceGwei: BigNumber.Value, feePercent: BigNumber.Value, baseAssetName: string, baseCurrencyName: string, feeAssetName: string, prices: Partial<Record<string, string>>) => {
    serviceFeeInFeeAsset: BigNumber;
    networkFeeInFeeAsset: BigNumber;
    totalFeeInFeeAsset: string;
};

declare function calculateNetworkFee(gasPriceGwei: BigNumber.Value, gasLimit: BigNumber.Value): string;

declare const calculateNetworkFeeInFeeAsset: (gasPriceGwei: BigNumber.Value, gasLimit: BigNumber.Value, baseCurrencyName: string, feeAssetName: string, prices: Partial<Record<string, string>>) => BigNumber;

declare function calculateServiceFeeInFeeAsset(amount: BigNumber.Value, baseAssetName: string, feeAssetName: string, feePercent: BigNumber.Value, prices: Partial<Record<string, string>>): BigNumber;

declare const checkIsToken: (address: string, provider?: ethers.Provider) => Promise<boolean>;

declare const generateSecret: () => string;

/**
 * Converts normalized blockchain ("machine-readable") number to denormalized ("human-readable") number.
 * @param input Any blockchain-normalized numeric value
 * @param decimals Blockchain asset precision
 * @returns BigNumber
 */
declare function denormalizeNumber(input: bigint, decimals: bigint): BigNumber;

/**
 * Converts denormalized ("human-readable") number to normalized ("machine-readable") number.
 * @param input Any numeric value
 * @param decimals Blockchain asset precision
 * @param roundingMode Rounding mode
 * @returns bigint
 */
declare function normalizeNumber(input: BigNumber.Value, decimals: BigNumber.Value, roundingMode: BigNumber.RoundingMode): bigint;

declare function isNetworkCodeInEnvironment(networkCode: string, env: string): boolean;

declare function parseExchangeTradeTransaction(tx: {
    data: string;
    value?: ethers.BigNumberish;
}): {
    name: "swapThroughOrionPool";
    args: {
        amount_spend: bigint;
        amount_receive: bigint;
        path: [string, ...string[]];
        is_exact_spend: boolean;
    };
} | {
    name: "fillThroughOrionPool";
    args: {
        order: {
            senderAddress: string;
            matcherAddress: string;
            baseAsset: string;
            quoteAsset: string;
            matcherFeeAsset: string;
            amount: bigint;
            price: bigint;
            matcherFee: bigint;
            nonce: bigint;
            expiration: bigint;
            buySide: 0 | 1;
            isPersonalSign: boolean;
            signature: `0x${string}`;
        };
        filledAmount: bigint;
        blockchainFee: bigint;
        path: [string, ...string[]];
    };
} | {
    name: "fillOrders";
    args: {
        orders: {
            buyOrder: {
                senderAddress: string;
                matcherAddress: string;
                baseAsset: string;
                quoteAsset: string;
                matcherFeeAsset: string;
                amount: bigint;
                price: bigint;
                matcherFee: bigint;
                nonce: bigint;
                expiration: bigint;
                buySide: 0 | 1;
                isPersonalSign: boolean;
                signature: `0x${string}`;
            };
            sellOrder: {
                senderAddress: string;
                matcherAddress: string;
                baseAsset: string;
                quoteAsset: string;
                matcherFeeAsset: string;
                amount: bigint;
                price: bigint;
                matcherFee: bigint;
                nonce: bigint;
                expiration: bigint;
                buySide: 0 | 1;
                isPersonalSign: boolean;
                signature: `0x${string}`;
            };
        };
        filledPrice: bigint;
        filledAmount: bigint;
    };
};

declare function toUpperCase<T extends string>(str: T): Uppercase<T>;

declare function toLowerCase<T extends string>(str: T): Lowercase<T>;

declare const isUppercasedNetworkCode: (value: string) => value is "ETH" | "BSC" | "FTM" | "OKC" | "DRIP" | "AVAX" | "BASE" | "POLYGON" | "OPBNB" | "INEVM" | "LINEA" | "ARB";

declare const getNativeCryptocurrencyName: (assetToAddress: Partial<Record<string, string>>) => string;

declare const laconicParse: <DataOut, DataIn>(data: DataIn, schema: Schema<DataOut, ZodTypeDef, DataIn>) => DataOut;

declare const isValidChainId: (chainId: string) => chainId is SupportedChainId;

declare const isKnownEnv: (env: string) => env is "production" | "staging" | "testing";

declare const removeFieldsFromObject: <T extends Record<string, unknown>, K extends keyof T>(obj: T, fields: K[]) => Omit<T, K>;

type WithReason = {
    reason: string;
};
type WithCodeError = Error & {
    code: number | string;
};
type WithMessage = {
    message: string;
};
type WithDataError = Error & {
    data: Record<string, unknown>;
};
type WithError = {
    error: Record<string | number | symbol, unknown>;
};
declare const makePartial: <Key extends string | number | symbol, Value>(value: Record<Key, Value>) => Partial<Record<Key, Value>>;
declare function isUnknownObject(x: unknown): x is {
    [key in PropertyKey]: unknown;
};
declare function isKeyOfObject<T extends object>(key: string | number | symbol, obj: T): key is keyof T;
declare function hasProp<T extends Record<string, unknown>, K extends PropertyKey>(obj: T, key: K): obj is T & Record<K, unknown>;
declare function isWithCode(candidate: unknown): candidate is WithCodeError;
declare function isWithReason(candidate: unknown): candidate is WithReason;
declare function isWithMessage(candidate: unknown): candidate is WithMessage;
declare function isWithError(candidate: unknown): candidate is WithError;
declare function isWithData(candidate: unknown): candidate is WithDataError;

declare const index$2_calculateFeeInFeeAsset: typeof calculateFeeInFeeAsset;
declare const index$2_calculateNetworkFee: typeof calculateNetworkFee;
declare const index$2_calculateNetworkFeeInFeeAsset: typeof calculateNetworkFeeInFeeAsset;
declare const index$2_calculateServiceFeeInFeeAsset: typeof calculateServiceFeeInFeeAsset;
declare const index$2_checkIsToken: typeof checkIsToken;
declare const index$2_denormalizeNumber: typeof denormalizeNumber;
declare const index$2_generateSecret: typeof generateSecret;
declare const index$2_getNativeCryptocurrencyName: typeof getNativeCryptocurrencyName;
declare const index$2_hasProp: typeof hasProp;
declare const index$2_isKeyOfObject: typeof isKeyOfObject;
declare const index$2_isKnownEnv: typeof isKnownEnv;
declare const index$2_isNetworkCodeInEnvironment: typeof isNetworkCodeInEnvironment;
declare const index$2_isUnknownObject: typeof isUnknownObject;
declare const index$2_isUppercasedNetworkCode: typeof isUppercasedNetworkCode;
declare const index$2_isValidChainId: typeof isValidChainId;
declare const index$2_isWithCode: typeof isWithCode;
declare const index$2_isWithData: typeof isWithData;
declare const index$2_isWithError: typeof isWithError;
declare const index$2_isWithMessage: typeof isWithMessage;
declare const index$2_isWithReason: typeof isWithReason;
declare const index$2_laconicParse: typeof laconicParse;
declare const index$2_makePartial: typeof makePartial;
declare const index$2_normalizeNumber: typeof normalizeNumber;
declare const index$2_parseExchangeTradeTransaction: typeof parseExchangeTradeTransaction;
declare const index$2_removeFieldsFromObject: typeof removeFieldsFromObject;
declare const index$2_toLowerCase: typeof toLowerCase;
declare const index$2_toUpperCase: typeof toUpperCase;
declare namespace index$2 {
    export {
        index$2_calculateFeeInFeeAsset as calculateFeeInFeeAsset,
        index$2_calculateNetworkFee as calculateNetworkFee,
        index$2_calculateNetworkFeeInFeeAsset as calculateNetworkFeeInFeeAsset,
        index$2_calculateServiceFeeInFeeAsset as calculateServiceFeeInFeeAsset,
        index$2_checkIsToken as checkIsToken,
        index$2_denormalizeNumber as denormalizeNumber,
        index$2_generateSecret as generateSecret,
        index$2_getNativeCryptocurrencyName as getNativeCryptocurrencyName,
        index$2_hasProp as hasProp,
        index$2_isKeyOfObject as isKeyOfObject,
        index$2_isKnownEnv as isKnownEnv,
        index$2_isNetworkCodeInEnvironment as isNetworkCodeInEnvironment,
        index$2_isUnknownObject as isUnknownObject,
        index$2_isUppercasedNetworkCode as isUppercasedNetworkCode,
        index$2_isValidChainId as isValidChainId,
        index$2_isWithCode as isWithCode,
        index$2_isWithData as isWithData,
        index$2_isWithError as isWithError,
        index$2_isWithMessage as isWithMessage,
        index$2_isWithReason as isWithReason,
        index$2_laconicParse as laconicParse,
        index$2_makePartial as makePartial,
        index$2_normalizeNumber as normalizeNumber,
        index$2_parseExchangeTradeTransaction as parseExchangeTradeTransaction,
        index$2_removeFieldsFromObject as removeFieldsFromObject,
        index$2_toLowerCase as toLowerCase,
        index$2_toUpperCase as toUpperCase,
    };
}

declare namespace index$1 {
    export {
        index$h as aggregator,
        index$f as blockchainService,
        index$3 as frontage,
        index$9 as indexer,
        index$b as priceFeed,
        index$5 as referralSystem,
    };
}

declare const signCancelOrder: (senderAddress: string, id: string, signer: ethers.Signer, chainId: SupportedChainId) => Promise<SignedCancelOrderRequest>;

declare const signOrder: (baseAssetAddr: string, quoteAssetAddr: string, side: 'BUY' | 'SELL', price: BigNumber.Value, amount: BigNumber.Value, matcherFee: BigNumber.Value, senderAddress: string, matcherAddress: string, serviceFeeAssetAddr: string, signer: ethers.Signer, chainId: SupportedChainId) => Promise<SignedOrder>;

declare const index_signCancelOrder: typeof signCancelOrder;
declare const index_signOrder: typeof signOrder;
declare namespace index {
    export {
        index_signCancelOrder as signCancelOrder,
        index_signOrder as signOrder,
    };
}

export { ADD_LIQUIDITY_GAS_LIMIT, APPROVE_ERC20_GAS_LIMIT, AggregatedAssets, AggregatedBalanceRequirement, ApproveFix, Asset, AssetPairUpdate, AtomicSwap, AtomicSwapLocal, Balance, BalanceIssue, BalanceRequirement, BasicAuthCredentials, CancelOrderRequest, DAY, DEFAULT_GAS_LIMIT, DEPOSIT_ERC20_GAS_LIMIT, DEPOSIT_ETH_GAS_LIMIT, DeepPartial, DepositFix, EnvConfig, FARMING_CLAIM_GAS_LIMIT, FARMING_EXIT_GAS_LIMIT, FARMING_STAKE_GAS_LIMIT, FARMING_WITHDRAW_GAS_LIMIT, FILL_ORDERS_GAS_LIMIT, Factory, GOVERNANCE_GET_REWARD_GAS_LIMIT, GOVERNANCE_STAKE_GAS_LIMIT, GOVERNANCE_UNSTAKE_GAS_LIMIT, GOVERNANCE_VOTE_GAS_LIMIT, HistoryTransactionStatus, INTERNAL_PROTOCOL_PRECISION, Json, KnownEnv, LIQUIDITY_MIGRATE_GAS_LIMIT, LOCKATOMIC_GAS_LIMIT, MIGRATE_GAS_LIMIT, NATIVE_CURRENCY_PRECISION, NetworkCode, Order, OrderSource, OrderbookItem, Orion, Pair, PositionStatus, REDEEMATOMIC_GAS_LIMIT, RedeemOrder, SERVICE_TOKEN, STAKE_ERC20_GAS_LIMIT, SWAP_THROUGH_ORION_POOL_GAS_LIMIT, SignedCancelOrderRequest, SignedOrder, SingleSwap, Source, SubOrder, SupportedChainId, SwapInfo, SwapInfoAlternative, SwapInfoBase, SwapInfoByAmountIn, SwapInfoByAmountOut, TOKEN_EXCEPTIONS, TickersBaseSearchParams, TickersCategories, TickersSortBy, TickersSortType, TransactionInfo, TxBridgePayload, TxDepositOrWithdrawPayload, TxLiquidityMigrationPayload, TxRedeemTwoAtomicsPayload, TxStatus, TxSwapThroughOrionPoolPayload, TxType, Unit, VOTE_ERC20_GAS_LIMIT, VerboseUnitConfig, WEEK_DAYS, WITHDRAW_GAS_LIMIT, YEAR, CANCEL_ORDER_TYPES as cancelOrderTypes, index$7 as config, index as crypt, developmentChains, _default as exchanges, mapping as exchangesMap, _default$4 as factories, generateSwapCalldata, _default$3 as networkCodes, orderStatuses, ORDER_TYPES as orderTypes, productionChains, index$1 as services, subOrderStatuses, index$2 as utils };
